# SPDX-FileCopyrightText: © 2025 Alexander Kromm <mmaulwurff@gmail.com>
# SPDX-License-Identifier: GPL-3.0-only
:properties:
:header-args: :comments no :mkdirp yes :noweb yes :results none
:end:

#+title: Ultimate Custom Doom (framework)

#+begin_src prog :tangle ../build/UltimateCustomDoomF/textcolor.txt
CDLightBlue { #111111 #99CCFF }
#+end_src

#+begin_src c :tangle ../build/UltimateCustomDoomF/menudef.txt
AddOptionMenu OptionsMenu { Submenu "$CD_MAIN", cd_MainMenu }

OptionMenu cd_MainMenu { Class cd_MainMenu }
OptionMenu cd_MainMenuStatic
{
  StaticText "========================================", CDLightBlue
  StaticText "Welcome to Ultimate Custom Doom!"        , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText ""
  Submenu    "The Manual", cd_Manual
  StaticText ""
  Submenu    "Builtins", cd_Builtins
  StaticText ""
}

OptionMenu cd_Builtins
{
  StaticText "========================================", CDLightBlue
  StaticText "Builtins"                                , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText ""
  Slider     "$CD_PLAYER_MAX_VIEW_PITCH"               , maxViewPitch, 0, 90, 5
  cd_Hint    "0 is not recommended without autoaim."
  cd_Hint    "90 is the default."
}

OptionMenu cd_CategoryMenu {}
OptionMenu cd_CategoryMenuStatic
{
  StaticText "========================================", CDLightBlue
  StaticText "(set dynamically)"                       , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText "All modifiers are zero-terminated."      , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText ""
}

OptionMenu cd_Manual
{
  StaticText "========================================", CDLightBlue
  StaticText "The Manual"                              , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText "This is Ultimate Custom Doom reference page."     , CDLightBlue
  StaticText "All useful information regarding the mod is here.", CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText "Zero-terminated modifiers."              , CDLightBlue
  StaticText "========================================", CDLightBlue
  StaticText ""
  StaticText "$CD_MANUAL", White
}
#+end_src

#+begin_src ini :tangle ../build/UltimateCustomDoomF/language.txt
[enu default]
CD_MAIN = "\c[CDLightBlue]⚒\c- Ultimate Custom Doom";

CD_PLAYER_MAX_VIEW_PITCH = "Max view pitch";

CD_MANUAL = "These modifiers have a default value of 0. They will not do\
anything until you change their values to something positive.\
\
Such are the monster modifiers, almost all player modifiers\
and all randomizer options.\
\
These options can be enabled individually by using any\
number above 0.\
\
Switching to 0 from a positive number during gameplay\
will not revert the changes done.\
\
To do that, you must set value to its default (most often 1),\
exit the menu, wait until the change is in effect, then zero-\
terminate the modifier,\
\
0 means that other mods' effects will not be overridden\
by Ultimate Custom Doom.";

[ru]
CD_PLAYER_MAX_VIEW_PITCH = "Максимальный угол обзора";

CD_MANUAL = "Эти модификаторы имеют значение по умолчанию 0. Они не будут делать\nничего, пока вы не измените значения на что-то положительное.\n\nТак ведут себя модификаторы монстров, почти все модификаторы игрока\nи все модификаторы рандомайзера.\n\nЭти настройки могут быть включены индивидуально с помощью любого\nчисла выше 0.\n\nПереключение на 0 с положительного числа во время игры\nне вернёт сделанные изменения.\n\nДля этого вы должны установить значение по умолчанию (чаще всего 1),\nвыйти из меню, подождать, пока изменения не вступят в силу, затем очистить\nнулевой модификатор установкой 0.\n\n0 означает, что эффекты других модов не будут переопределены\nUltimate Custom Doom.";
#+end_src

#+begin_src c :tangle ../build/UltimateCustomDoomF/cvarinfo.txt
server string cd_settings = "";
#+end_src

#+begin_src prog :tangle ../build/UltimateCustomDoomF/mapinfo.txt
GameInfo { EventHandlers = "cd_EventHandler" }
#+end_src

#+begin_src c :tangle ../build/UltimateCustomDoomF/zscript.txt
version 4.14.2

#include "zscript/cd_Engine.zs"
#include "zscript/cd_Hint.zs"

class cd_Category
{
  static cd_Category from(string name)
  {
    let result = new("cd_Category");
    result.mName = name;
    return result;
  }

  string mName;
  Array<cd_Option> mOptions;
}

class cd_Option
{
  string mName;

  class<Object> mClass;
  Function<play void(double)> mSetter;
}

class cd_OptionParser
{
  /// @returns either "", option, category;
  /// or error message, NULL.
  static string, cd_Option, string parseLump(int lumpIndex)
  {
    string lumpName = Wads.getLumpFullName(lumpIndex);

    let [nameError, category, name] = parseName(lumpName);
    if (nameError.length() != 0) return lumpName .. ": " .. nameError, NULL, "";

    let [contentsError, aClass, setter] = parseContents(Wads.readLump(lumpIndex));
    if (contentsError.length() != 0) return lumpName .. ": " .. contentsError, NULL, "";

    let [constructError, option] = construct(name, aClass, setter);
    if (constructError.length() != 0) return lumpName .. ": " .. constructError, NULL, "";

    return "", option, category;
  }

  /// @returns either "", category, option name;
  /// or error message, "", "".
  private static string, string, string parseName(string fullLumpName)
  {
    Array <string> pathParts;
    fullLumpName.split(pathParts, "/");

    string category = pathParts.size() > 1 ? pathParts[pathParts.size() - 2] : "general";
    string fileName = pathParts[pathParts.size() - 1];

    Array<string> parts;
    fileName.split(parts, ".");
    if (parts.size() != 3)
      return string.format("bad lump name format, expected: cd_option.Name.json"), "", "";

    return "", category, parts[1];
  }

  /// @returns either: "", class, setter;
  /// or: error message, "", "", "".
  private static string, string, string parseContents(string serialized)
  {
    let aDictionary = Dictionary.fromString(serialized);

    Array<string> errors;
    string aClass = read("class", aDictionary, errors);
    string setter = read("setter", aDictionary, errors);

    if (errors.size() != 0) return cd_su.join(errors), "", "";

    return "", aClass, setter;
  }

  private static string read(string key, Dictionary aDictionary, out Array<string> errors)
  {
    string result = aDictionary.at(key);
    if (result == "") errors.push(string.format("key %s not found", key));
    return result;
  }

  /// @returns either "", cd_Option;
  /// or error message, NULL.
  private static string, cd_Option construct(string name,
                                             string aClass,
                                             string setter)
  {
    cd_Option result = new("cd_Option");

    result.mName = name;
    result.mClass = aClass;
    result.mSetter = (Function<play void(double)>)(findFunction(aClass, setter));

    Array<string> errors;
    if (result.mClass == NULL) errors.push("class is null");
    if (result.mSetter == NULL) errors.push("setter is null");

    if (errors.size() != 0) return cd_su.join(errors), NULL;

    return "", result;
  }
}

class cd_EventHandler : StaticEventHandler
{
  static clearscope cd_EventHandler getInstance()
  {
    return cd_EventHandler(StaticEventHandler.find("cd_EventHandler"));
  }

  override void onEngineInitialize()
  {
    string dataLump = "cd_option";
    for (int i = Wads.findLump(dataLump, 0, Wads.AnyNamespace);
         i != -1;
         i = Wads.findLump(dataLump, i + 1, Wads.AnyNamespace))
    {
      let [error, option, category] = cd_OptionParser.parseLump(i);

      if (error.length() != 0)
      {
        Console.printf("%s", error);
        continue;
      }

      if (!mCategoryIndices.checkKey(category))
      {
        mCategoryIndices.insert(category, mCategories.size());
        mCategories.push(cd_Category.from(category));
      }

      mCategories[mCategoryIndices.get(category)].mOptions.push(option);
    }
  }

  override void worldTick()
  {
    int categoriesCount = getCategoriesCount();
    for (int i = 0; i < categoriesCount; ++i)
    {
      let category = getCategory(i);
      int optionsCount = category.mOptions.size();
      for (int j = 0; j < optionsCount; ++j)
      {
        cd_Option option = category.mOptions[j];
        string tag = category.mName .. ":" .. option.mName;
        double setting = getSetting(tag);
        if (setting == 0) setting = 1;
        option.mSetter.call(setting);
      }
    }
  }

  double getSetting(string tag) const
  {
    return Dictionary.fromString(cd_settings).at(tag).toDouble();
  }

  clearscope void setSetting(string tag, double value)
  {
    let settings = Dictionary.fromString(cd_settings);
    settings.insert(tag, string.format("%f", value));
    CVar.GetCvar("cd_settings", players[consolePlayer]).setString(settings.toString());
  }

  int getCategoriesCount() const { return mCategories.size(); }
  cd_Category getCategory(int i) const { return mCategories[i]; }

  int getOptionsCount(string category) const { return find(category).mOptions.size(); }
  cd_Option getOption(string category, int i) const { return find(category).mOptions[i]; }

  private cd_Category find(string category)
  {
    return mCategories[mCategoryIndices.get(category)];
  }

  private Array<cd_Category> mCategories;
  private Map<string, int> mCategoryIndices;
}

class cd_OptionItem : OptionMenuItemTextField
{
  override bool, string getString(int i)
  {
    if (i != 0) return false, "";

    return true, string.format("%.1f", cd_EventHandler.getInstance().getSetting(mTag));
  }

  override bool setString(int i, String s)
  {
    double corrected = max(0, s.toDouble());

    cd_EventHandler.getInstance().setSetting(mTag, corrected);
    return Super.setString(i, string.format("%f", corrected));
  }

  string mTag;
}

class cd_CategorySubmenu : OptionMenuItemSubmenu
{
  override bool activate()
  {
    Super.activate();

    let categoryMenu = OptionMenu(Menu.getCurrentMenu());
    categoryMenu.mDesc.mItems =
      OptionMenuDescriptor(MenuDescriptor.getDescriptor("cd_CategoryMenuStatic")).mItems;
    let titleText = OptionMenuItemStaticText(categoryMenu.mDesc.mItems[1]);
    titleText.initDirect(cd_MainMenu.localizeCategoryName(mCategory), titleText.mColor);

    let eventHandler = cd_EventHandler.getInstance();
    int optionsCount = eventHandler.getOptionsCount(mCategory);
    for (int i = 0; i < optionsCount; ++i)
    {
      cd_Option option = eventHandler.getOption(mCategory, i);
      let item = new("cd_OptionItem");
      item.init(cd_MainMenu.localizeOptionName(option.mName), "");
      item.mTag = mCategory .. ":" .. option.mName;
      categoryMenu.mDesc.mItems.push(item);
    }

    if (categoryMenu.mDesc.mSelectedItem <= 0)
      categoryMenu.mDesc.mSelectedItem = categoryMenu.firstSelectable();

    return true;
  }

  string mCategory;
}

class cd_MainMenu : OptionMenu
{
  override void init(Menu parent, OptionMenuDescriptor descriptor)
  {
    descriptor.mItems =
      OptionMenuDescriptor(MenuDescriptor.getDescriptor("cd_MainMenuStatic")).mItems;

    let eventHandler = cd_EventHandler.getInstance();
    int categoriesCount = eventHandler.getCategoriesCount();
    for (int i = 0; i < categoriesCount; ++i)
    {
      string categoryName = eventHandler.getCategory(i).mName;

      let submenu = new("cd_CategorySubmenu");
      submenu.init(localizeCategoryName(categoryName), "cd_CategoryMenu");
      submenu.mCategory = categoryName;

      descriptor.mItems.push(submenu);
    }

    Super.init(parent, descriptor);
  }

  static string localizeCategoryName(string name)
  {
    return localizeName("CD_CATEGORY_", name);
  }

  static string localizeOptionName(string name)
  {
    return localizeName("CD_OPTION_", name);
  }

  static string localizeName(string prefix, string categoryName)
  {
    string localizationTag = prefix .. categoryName;
    string result = StringTable.localize(localizationTag, false);
    if (result == localizationTag) result = categoryName;

    return result;
  }
}

<<module("StringUtils")>>
#+end_src

#+begin_src c :tangle ../build/UltimateCustomDoomF/zscript/cd_Hint.zs
/// This class provides the Hint Option Menu item.
/// Hint is a static text that is visible only if the items above are selected.
/// The number of items above is configurable, and by default is 1.
class OptionMenuItemCd_Hint : OptionMenuItemStaticText
{
  /// nAbove means for how many selectable items above this hint should appear.
  OptionMenuItemCd_Hint Init(String label, int nAbove = 1)
  {
    Super.InitDirect(label, Font.CR_WHITE);
    if (nAbove < 1) { nAbove = 1; }
    _nAbove = nAbove;
    return self;
  }

  override int Draw(OptionMenuDescriptor desc, int y, int indent, bool selected)
  {
    return isAboveSelected(desc)
      ? Super.Draw(desc, y, indent, selected)
      : -1;
  }

  private bool isAboveSelected(OptionMenuDescriptor desc)
  {
    int selfIndex = desc.mItems.find(self);
    int aboveEnd  = selfIndex - 1;

    while (aboveEnd >= 0 && !desc.mItems[aboveEnd].Selectable()) { --aboveEnd; }

    int aboveBegin      = aboveEnd;
    int foundSelectable = 0;
    for (; aboveBegin >= 0 && foundSelectable < _nAbove; --aboveBegin)
    {
      if (desc.mItems[aboveBegin].Selectable())
      {
        ++foundSelectable;
      }
    }
    ++aboveBegin;

    int  selected        = desc.mSelectedItem;
    bool isAboveSelected = (aboveBegin <= selected && selected <= aboveEnd);

    return isAboveSelected;
  }

  private int _nAbove;
}
#+end_src

* Modules

[[file:../modules/StringUtils.org][StringUtils]]
#+name: module
#+begin_src emacs-lisp :var module-name = "" :exports none
(org-babel-tangle-file (concat "../modules/" module-name ".org"))

(string-replace "NAMESPACE_" "cd_"
                (with-temp-buffer
                  (insert-file-contents (format "../build/%1$s/%1$s.zs" module-name))
                  (buffer-string)))
#+end_src

* Options

#+begin_src js :tangle ../build/UltimateCustomDoomF/zscript/cd_Engine.zs
class cd_Engine play
{
  private static PlayerPawn getPawn()
  {
    if (players[consolePlayer].mo == NULL) throwAbortException("player pawn is null");
    return players[consolePlayer].mo;
  }

  private static readonly<PlayerPawn> getDefaultPawn()
  {
    return getDefaultByType(getPawn().getClass());
  }
}
#+end_src

** Weapon Damage

#+begin_src js :tangle ../build/UltimateCustomDoomF/options/gameplay/cd_option.WeaponDamage.json
{
  "class": "cd_Engine",
  "setter": "setPawnWeaponDamage"
}
#+end_src
#+begin_src ini :tangle ../build/UltimateCustomDoomF/language.txt
[enu default]
CD_OPTION_WeaponDamage = "Weapon damage multiplier";
#+end_src
#+begin_src js :tangle ../build/UltimateCustomDoomF/zscript/cd_Engine.zs
extend class cd_Engine
{
  static void setPawnWeaponDamage(double value)
  {
    getPawn().damageMultiply = getDefaultPawn().damageMultiply * value;
  }
}
#+end_src

** Taken Damage

#+begin_src js :tangle ../build/UltimateCustomDoomF/options/gameplay/cd_option.TakenDamage.json
{
  "class": "cd_Engine",
  "setter": "setPawnTakenDamage"
}
#+end_src
#+begin_src ini :tangle ../build/UltimateCustomDoomF/language.txt
[enu default]
CD_OPTION_TakenDamage = "Damage taken multiplier";
#+end_src
#+begin_src js :tangle ../build/UltimateCustomDoomF/zscript/cd_Engine.zs
extend class cd_Engine
{
  static void setPawnTakenDamage(double value)
  {
    getPawn().damageFactor = getDefaultPawn().damageFactor * value;
  }
}
#+end_src

** Categories

#+begin_src ini :tangle ../build/UltimateCustomDoomF/language.txt
[enu default]
CD_CATEGORY_Gameplay = "Gameplay";
#+end_src

* Run

#+begin_src elisp :lexical t
(load-file "../build/TestRunner/dt-scripts.el")
(org-babel-tangle)
(dt-run-tests "../build/UltimateCustomDoomF" "wait 2;")
#+end_src
