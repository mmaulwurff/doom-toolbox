# SPDX-FileCopyrightText: Â© 2019 Alexander Kromm <mmaulwurff@gmail.com>
# SPDX-License-Identifier: BSD-3-Clause
#+property: header-args :comments no :mkdirp yes :noweb yes :results none

#+title: Typist.pk3 v0.7.4

Typist.pk3 turns FPS games into typing exercises.

TODO: add instructions.

* PlayerHandler

** ~PlayerHandler~

#+begin_src c :tangle build/Typist.pk3/zscript/player_handler/player_handler.zs

// Handles the game for one player.
class tt_PlayerHandler abstract
{
  abstract void reset(int playerNumber);

  abstract void processKey(tt_Character character);

  // Type is from InputEvent.EGenericEvent.
  abstract void processInput(int type);

  abstract void tick();

  abstract void reportDead(Actor dead);

  abstract bool isCapturingKeys();

  abstract void unlockMode();

  abstract void forceCombat();

  ui abstract void draw(RenderEvent event);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_PlayerHandlerMock : tt_PlayerHandler
{
  static tt_PlayerHandlerMock of() { return new("tt_PlayerHandlerMock"); }

  override void reset(int playerNumber) { throwAbortException("implement this!"); }

  override void processKey(tt_Character character)
  {
    ++_mock_processKey_called;
  }

  override void processInput(int type)
  {
    throwAbortException("implement this!");
  }

  void expect_processKey(int expected = 1)
  {
    _mock_processKey_expected = expected;
    _mock_processKey_called = 0;
  }

  private int _mock_processKey_expected;
  private int _mock_processKey_called;

  override void tick()
  {
    ++_mock_tick_called;
  }

  void expect_tick(int expected = 1)
  {
    _mock_tick_expected = expected;
    _mock_tick_called = 0;
  }

  private int _mock_tick_expected;
  private int _mock_tick_called;

  override void reportDead(Actor dead)
  {
    ++_mock_reportDead_called;
  }

  void expect_reportDead(int expected = 1)
  {
    _mock_reportDead_expected = expected;
    _mock_reportDead_called = 0;
  }

  private int _mock_reportDead_expected;
  private int _mock_reportDead_called;

  override bool isCapturingKeys()
  {
    ++_mock_isCapturingKeys_called;
    return _mock_isCapturingKeys;
  }

  void expect_isCapturingKeys(bool value, int expected = 1)
  {
    _mock_isCapturingKeys = value;
    _mock_isCapturingKeys_expected = expected;
    _mock_isCapturingKeys_called = 0;
  }

  private bool _mock_isCapturingKeys;
  private int _mock_isCapturingKeys_expected;
  private int _mock_isCapturingKeys_called;

  override void unlockMode()
  {
    ++_mock_unlockMode_called;
  }

  void expect_unlockMode(int expected = 1)
  {
    _mock_unlockMode_expected = expected;
    _mock_unlockMode_called = 0;
  }

  private int _mock_unlockMode_expected;
  private int _mock_unlockMode_called;

  override void forceCombat()
  {
    ++_mock_forceCombat_called;
  }

  void expect_forceCombat(int expected = 1)
  {
    _mock_forceCombat_expected = expected;
    _mock_forceCombat_called = 0;
  }

  private int _mock_forceCombat_expected;
  private int _mock_forceCombat_called;

  override void draw(RenderEvent event)
  {
    ++_mock_draw_called;
  }

  void expect_draw(int expected = 1)
  {
    _mock_draw_expected = expected;
    _mock_draw_called = 0;
  }

  private int _mock_draw_expected;
  private int _mock_draw_called;
}
#+end_src

** ~PlayerSupervisor~

#+begin_src c :tangle build/Typist.pk3/zscript/player_handler/player_supervisor.zs

// Handles Typist.pk3 features for one player.
class tt_PlayerSupervisor : tt_PlayerHandler
{
  static tt_PlayerSupervisor of(int playerNumber)
  {
    let result = new("tt_PlayerSupervisor");
    result.reset(playerNumber);
    return result;
  }

  override void reset(int playerNumber)
  {
    let playerSource     = tt_PlayerSourceImpl.of(playerNumber);
    let clock            = tt_TotalClock      .of();

    let soundSettings    = tt_SoundSettingsImpl.of(playerSource);
    let soundPlayer      = tt_PlayerSoundPlayer.of(playerSource, soundSettings);

    let answerReporter   = tt_SoundAnswerReporter  .of(soundPlayer);
    let modeReporter     = tt_SoundModeReporter    .of(soundPlayer);
    let keyPressReporter = tt_SoundKeyPressReporter.of(soundPlayer, soundSettings);

    let manualModeSource = tt_SettableMode .of();
    let playerInput      = tt_PlayerInput  .of(manualModeSource, keyPressReporter);
    let deathReporter    = tt_DeathReporter.of();
    let settings         = tt_SettingsImpl .of(playerSource);

    let originSource     = tt_PlayerOriginSource.of(playerSource);
    let targetRadar      = tt_TargetRadar       .of(originSource);
    let radarStaleMarker = tt_StaleMarkerImpl   .of(clock);
    let radarCacheDirty  = tt_TargetSourceCache .of(targetRadar, radarStaleMarker);
    let radarCache       = tt_TargetSourcePruner.of(radarCacheDirty);
    let lesson           = makeLesson(settings, playerSource);

    let targetRegistry = makeTargetRegistry(radarCache, lesson, deathReporter, clock);

    let answerStateSource = tt_PressedAnswerState.of();

    let pressMatcher = tt_QuestionAnswerMatcher
      .of(targetRegistry, playerInput, playerSource, answerStateSource);

    let hastyMatcher = tt_HastyQuestionAnswerMatcher
      .of(targetRegistry, playerInput, playerSource, answerReporter);

    let targetOriginSource = tt_OriginSourceCache
      .of(tt_SelectableOriginSource.of(hastyMatcher, pressMatcher, settings),
          tt_StaleMarkerImpl.of(clock));

    let projector        = tt_Projector           .of(targetRegistry, playerSource);
    let visibilityFilter = tt_VisibilityFilter    .of(projector, playerSource);
    let widgetRegistry   = tt_TargetWidgetRegistry.of(visibilityFilter);
    let widgetSorter     = tt_SorterByDistance    .of(widgetRegistry, originSource);

    let modeSource = makeModeSource(targetRegistry,
                                    playerSource,
                                    manualModeSource,
                                    modeReporter,
                                    clock,
                                    radarCache);

    let inputManager = tt_PassThroughInputManager
      .of(tt_InputByModeManager.of(modeSource, playerInput));

    let commandSettings = tt_CommandSettingsImpl.of(playerSource);
    Array<tt_Activatable> commands =
    {
      tt_PassThrough.of(inputManager, commandSettings)
    };

    let commandDispatcher = tt_CommandDispatcher.of(playerInput,
                                                    commands,
                                                    answerReporter,
                                                    answerStateSource,
                                                    settings);

    let oldModeSource         = tt_SettableMode.of();
    let inputBlockAfterCombat = tt_InputBlockAfterCombat
      .of(playerInput, modeSource, oldModeSource);


    let infoPanel = tt_InfoPanel.of(modeSource,
                                    playerInput,
                                    commandDispatcher,
                                    targetRegistry,
                                    settings,
                                    playerSource);

    Array<tt_View> views = {
      tt_TargetOverlay.of(widgetSorter, playerInput, settings, modeSource),
      tt_Frame.of(modeSource),
      infoPanel
    };

    let targetSender = tt_TargetOriginSender.of(targetOriginSource);

    Array<tt_Effect> effects = {
      tt_Gunner.of(targetOriginSource, targetSender),
      tt_AnswerResetter.of(answerStateSource, playerInput),
      tt_MatchWatcher.of(answerStateSource, answerReporter, targetOriginSource)
    };

    Array<tt_KeyProcessor> keyProcessors = {inputBlockAfterCombat, answerStateSource};

    _keyProcessor       = tt_KeyProcessors.of(keyProcessors);
    _deathReporter      = deathReporter;
    _targetRegistry     = targetRegistry;
    _view               = tt_ConditionalView.of(tt_Views.of(views));
    _modeSource         = modeSource;
    _targetWidgetSource = projector;
    _commandDispatcher  = commandDispatcher;
    _manualModeSource   = manualModeSource;
    _inputManager       = inputManager;
    _oldModeSource      = oldModeSource;
    _inputBlockAfterCombat = inputBlockAfterCombat;
    _effects            = tt_Effects.of(effects);
  }

  override void processKey(tt_Character character)
  {
    _keyProcessor.processKey(character);
  }

  override void processInput(int type)
  {
    _inputManager.processInput(type);
  }

  override void tick()
  {
    _commandDispatcher.activate();
    _inputManager.manageInput();

    _inputBlockAfterCombat.update();
    _oldModeSource.setMode(_modeSource.getMode());

    _effects.doEffect();
  }

  override void reportDead(Actor dead)
  {
    _deathReporter.reportDead(dead);
  }

  override bool isCapturingKeys()
  {
    return _inputManager.isCapturingKeys();
  }

  override void unlockMode()
  {
    _manualModeSource.setMode(tt_Mode.None);
  }

  override void forceCombat()
  {
    _manualModeSource.setMode(tt_Mode.Combat);
  }

  override void draw(RenderEvent event)
  {
    _view.draw(event);
  }

  // TODO: restore this doc.
  // Attention: see docs/adding-new-lesson.md before editing this function.
  // TODO: make string set lessons set data?
  private static tt_Lesson makeLesson(tt_Settings settings,
                                      tt_PlayerSource playerSource)
  {
    let randomLessonSettings = tt_RandomCharactersLessonSettingsImpl.of(playerSource);

    let random      = tt_RandomCharactersLesson.of(randomLessonSettings);
    let gzdoom      = tt_StringSet.of("tt_gzdoom");
    let cpp         = tt_StringSet.of("tt_cpp");
    let maths       = tt_MathsLesson.of();
    let english1000 = tt_StringSet.of("tt_1000");
    let russian1000 = tt_StringSet.of("tt_1000_ru");
    let custom      = tt_StringSet.of("typist_custom_text");
    let nix         = tt_StringSet.of("tt_nix");

    Array<tt_Lesson> lessonsForMixed =
      {random, gzdoom, cpp, maths, english1000, russian1000, custom, nix};
    let mixed = tt_MixedLesson.of(settings, lessonsForMixed);

    Array<tt_Lesson> lessonsForSelection =
      {random, gzdoom, cpp, maths, english1000, russian1000, mixed, custom, nix};
    return tt_SelectedLesson.of(settings, lessonsForSelection);
  }

  private static tt_ModeSource makeModeSource(tt_KnownTargetSource knownTargetSource,
                                              tt_PlayerSource      playerSource,
                                              tt_ModeSource        manualModeSource,
                                              tt_ModeReporter      modeReporter,
                                              tt_Clock             clock,
                                              tt_TargetSource      targetSource)
  {
    let autoModeSource = tt_AutoModeSource
      .of(knownTargetSource, playerSource);

    let delayedCombatModeSource = tt_DelayedCombatModeSource
      .of(clock, autoModeSource, targetSource);

    Array<tt_ModeSource> modeSources =
      {manualModeSource, delayedCombatModeSource, autoModeSource};

    let cascade  = tt_ModeCascade.of(modeSources);
    let reporter = tt_ReportedModeSource.of(modeReporter, cascade);

    return reporter;
  }

  private static tt_KnownTargetSource makeTargetRegistry(
    tt_TargetSource   targetSource,
    tt_Lesson         lesson,
    tt_TargetSource   deathReporter,
    tt_Clock          clock)
  {
    let registry      = tt_TargetRegistry .of(targetSource, lesson, deathReporter);
    let staleMarker   = tt_StaleMarkerImpl.of(clock);
    let registryCache = tt_KnownTargetSourceCache.of(registry, staleMarker);

    return registryCache;
  }

  private tt_KeyProcessor       _keyProcessor;
  private tt_KnownTargetSource  _targetRegistry;
  private tt_DeathReporter      _deathReporter;
  private tt_View               _view;
  private tt_ModeSource         _modeSource;
  private tt_TargetWidgetSource _targetWidgetSource;
  private tt_CommandDispatcher  _commandDispatcher;
  private tt_ModeStorage        _manualModeSource;
  private tt_PassThroughInputManager _inputManager;
  private tt_SettableMode       _oldModeSource;
  private tt_InputBlockAfterCombat _inputBlockAfterCombat;
  private tt_Effect             _effects;
}
#+end_src

* Server

#+begin_src c :tangle build/Typist.pk3/zscript/server/server.zs

class tt_Server
{
  static tt_Server of()
  {
    let result = new("tt_Server");
    result._globalChangers = tt_WorldChangers.ofNone();
    return result;
  }

  void addPlayer(int playerNumber)
  {
    let playerSource       = tt_PlayerSourceImpl    .of(playerNumber);
    let originSource       = tt_PlayerOriginSource  .of(playerSource);
    let targetOriginSource = tt_ExternalOriginSource.of();
    let settings           = tt_SettingsImpl        .of(playerSource);
    let targetRadar        = tt_TargetRadar         .of(originSource);
    let radarStaleMarker   = tt_StaleMarkerImpl     .of(tt_TotalClock.of());
    let radarCacheDirty    = tt_TargetSourceCache   .of(targetRadar, radarStaleMarker);
    let radarCache         = tt_TargetSourcePruner  .of(radarCacheDirty);

    Array<tt_WorldChanger> targetChangers = {
      tt_HorizontalAimer.of(targetOriginSource, playerSource),
      tt_VerticalAimer.of(targetOriginSource, playerSource, settings),
      tt_Firer.of(playerSource)
    };

    _targetSources[playerNumber]  = targetOriginSource;
    _targetChangers[playerNumber] = tt_WorldChangers.of(targetChangers);

    Array<tt_WorldChanger> globalChangers = {
      tt_ProjectileSpeedController.of(originSource, playerSource),
      tt_EnemySpeedController.of(radarCache, playerSource)
    };

    _globalChangers.add(tt_WorldChangers.of(globalChangers));
  }

  play void react(int playerNumber, vector3 targetOrigin)
  {
    _targetSources[playerNumber].setOrigin(tt_Origin.of(targetOrigin));
    _targetChangers[playerNumber].changeWorld();
  }

  play void tick() { _globalChangers.changeWorld(); }

  tt_ExternalOriginSource _targetSources[MAXPLAYERS];
  tt_WorldChanger         _targetChangers[MAXPLAYERS];
  tt_WorldChangers        _globalChangers;
}
#+end_src

* Activatable

** ~Activatable~

#+begin_src c :tangle build/Typist.pk3/zscript/activatable/activatable.zs

// This interface represents a game element that can be activated by the same
// way the target is damaged. Such elements can be considered generic targets.
class tt_Activatable abstract
{
  abstract void activate();

  abstract tt_Strings getCommands();

  abstract bool isVisible();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ActivatableMock : tt_Activatable
{
  static tt_ActivatableMock of() { return new("tt_ActivatableMock"); }

  override void activate()
  {
    ++_mock_activate_called;
  }

  void expect_activate(int expected = 1)
  {
    _mock_activate_expected = expected;
    _mock_activate_called = 0;
  }

  private int _mock_activate_expected;
  private int _mock_activate_called;

  override tt_Strings getCommands()
  {
    ++_mock_getCommands_called;
    return _mock_getCommands;
  }

  void expect_getCommands(tt_Strings value, int expected = 1)
  {
    _mock_getCommands = value;
    _mock_getCommands_expected = expected;
    _mock_getCommands_called = 0;
  }

  private tt_Strings _mock_getCommands;
  private int _mock_getCommands_expected;
  private int _mock_getCommands_called;

  override bool isVisible()
  {
    ++_mock_isVisible_called;
    return _mock_isVisible;
  }

  void expect_isVisible(bool value, int expected = 1)
  {
    _mock_isVisible = value;
    _mock_isVisible_expected = expected;
    _mock_isVisible_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. "activate",
            _mock_activate_expected == _mock_activate_called)
      .push(getClassName() .. "getCommands",
            _mock_getCommands_expected == _mock_getCommands_called)
      .push(getClassName() .. "isVisible",
            _mock_isVisible_expected == _mock_isVisible_called);
  }

  private bool _mock_isVisible;
  private int _mock_isVisible_expected;
  private int _mock_isVisible_called;
}
#+end_src

** ~PassThrough~

#+begin_src c :tangle build/Typist.pk3/zscript/activatable/pass_through.zs

class tt_PassThrough : tt_Activatable
{
  static tt_PassThrough of(tt_PassThroughInputManager passThroughInputManager,
                           tt_CommandSettings settings)
  {
    let result = new("tt_PassThrough");
    result._inputManager = passThroughInputManager;
    result._settings     = settings;
    return result;
  }

  override void activate()
  {
    _inputManager.setPassThrough();
  }

  override tt_Strings getCommands()
  {
    return tt_Strings.ofOne(_settings.getPassThroughCommand());
  }

  override bool isVisible()
  {
    return true;
  }

  private tt_PassThroughInputManager _inputManager;
  private tt_CommandSettings _settings;
}

#+end_src

** ~CommandDispatcher~

#+begin_src c :tangle build/Typist.pk3/zscript/activatable/command_dispatcher.zs

// Contains Activatables and activates() ones with commands matching answer.
class tt_CommandDispatcher : tt_Activatable
{
  static tt_CommandDispatcher of(tt_AnswerSource       answerSource,
                                 Array<tt_Activatable> activatables,
                                 tt_AnswerReporter     answerReporter,
                                 tt_AnswerStateSource  answerStateSource,
                                 tt_Settings           globalSettings)
  {
    let result = new("tt_CommandDispatcher");

    result._answerSource      = answerSource;
    result._activatables.Copy(activatables);
    result._answerReporter    = answerReporter;
    result._answerStateSource = answerStateSource;
    result._globalSettings    = globalSettings;

    return result;
  }

  override void activate()
  {
    let answerState = _answerStateSource.getAnswerState();
    if (!answerState.isReady() && !_globalSettings.isFastConfirmation()) return;

    let answer       = _answerSource.getAnswer();
    let answerString = answer.getString();

    foreach (activatable : _activatables)
    {
      bool isActivated = tryActivate(activatable, answerString);

      if (isActivated)
      {
        _answerReporter.reportMatch();
        _answerSource.reset();
        _answerStateSource.reset();
        return;
      }
    }
  }

  override tt_Strings getCommands()
  {
    let result = tt_Strings.of();

    foreach (activatable : _activatables)
    {
      if (!activatable.isVisible()) continue;

      let commands = activatable.getCommands();

      uint nCommands = commands.size();
      for (uint c = 0; c < nCommands; ++c)
        result.add(commands.at(c));
    }

    return result;
  }

  override bool isVisible()
  {
    return true;
  }

  private bool tryActivate(tt_Activatable activatable, string answer)
  {
    let commands = activatable.getCommands();

    uint nCommands = commands.size();
    for (uint c = 0; c < nCommands; ++c)
    {
      string command    = commands.at(c);
      bool   isMatching = (command == answer);

      if (isMatching)
      {
        activatable.activate();
        return true;
      }
    }

    return false;
  }

  private tt_AnswerSource       _answerSource;
  private Array<tt_Activatable> _activatables;
  private tt_AnswerReporter     _answerReporter;
  private tt_AnswerStateSource  _answerStateSource;
  private tt_Settings           _globalSettings;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_CommandDispatcher: checkActivate";
  let env = tt_CommandDispatcherTestEnvironment.of();

  let str    = "Hello";
  let answer = tt_Answer.of(str);
  env.answerSource.expect_getAnswer(answer);

  let commands1 = tt_Strings.of();
  let commands2 = tt_Strings.of();
  commands2.add(str);
  env.activatable1.expect_getCommands(commands1);
  env.activatable2.expect_getCommands(commands2);
  env.activatable2.expect_activate();
  env.answerReporter.expect_reportMatch();
  env.answerStateSource
    .expect_getAnswerState(tt_AnswerState.of(tt_AnswerState.Ready));
  env.answerStateSource.expect_reset();
  env.answerSource.expect_reset();

  env.commandDispatcher.activate();

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_CommandDispatcher: checkGetCommands";
  let env = tt_CommandDispatcherTestEnvironment.of();

  let commands1 = tt_Strings.of();
  let commands2 = tt_Strings.of();
  commands1.add("1");
  commands1.add("2");
  commands2.add("3");
  commands2.add("4");
  env.activatable1.expect_getCommands(commands1);
  env.activatable2.expect_getCommands(commands2);
  env.activatable1.expect_isVisible(true);
  env.activatable2.expect_isVisible(true);

  let allCommands = env.commandDispatcher.getCommands();
  let size        = allCommands.size();

  it("tt_CommandDispatcher: check get commands: All commands are collected",
     AssertEval(size, "==", 4));
  it("tt_CommandDispatcher: check get commands: The first command is collected",
     Assert(allCommands.contains("1")));
  it("tt_CommandDispatcher: check get commands: The second command is collected",
     Assert(allCommands.contains("2")));
  it("tt_CommandDispatcher: check get commands: The third command is collected",
     Assert(allCommands.contains("3")));
  it("tt_CommandDispatcher: check get commands: The forth command is collected",
     Assert(allCommands.contains("4")));

  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_CommandDispatcherTestEnvironment
{
  static tt_CommandDispatcherTestEnvironment of()
  {
    let result = new("tt_CommandDispatcherTestEnvironment");
    result.activatable1      = tt_ActivatableMock.of();
    result.activatable2      = tt_ActivatableMock.of();
    Array<tt_Activatable> activatables = {result.activatable1, result.activatable2};
    result.answerSource      = tt_AnswerSourceMock     .of();
    result.answerReporter    = tt_AnswerReporterMock   .of();
    result.answerStateSource = tt_AnswerStateSourceMock.of();
    result.globalSettings    = tt_SettingsMock         .of();
    result.commandDispatcher = tt_CommandDispatcher.of(result.answerSource,
                                                       activatables,
                                                       result.answerReporter,
                                                       result.answerStateSource,
                                                       result.globalSettings);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return activatable1.getSatisfaction()
      .add(activatable2.getSatisfaction())
      .add(answerSource.getSatisfaction())
      .add(answerReporter.getSatisfaction())
      .add(answerStateSource.getSatisfaction())
      .add(globalSettings.getSatisfaction());
  }

  tt_ActivatableMock activatable1;
  tt_ActivatableMock activatable2;
  tt_AnswerSourceMock answerSource;
  tt_AnswerReporterMock answerReporter;
  tt_AnswerStateSourceMock answerStateSource;
  tt_SettingsMock globalSettings;
  tt_CommandDispatcher commandDispatcher;
}
#+end_src

* Aimer

** ~HorizontalAimer~

#+begin_src c :tangle build/Typist.pk3/zscript/aimer/horizontal_aimer.zs

// Implements tt_WorldChanger interface by rotating the player.
// This implementation only aims horizontally. Hope for the vertical autoaim!
class tt_HorizontalAimer : tt_WorldChanger
{
  static tt_HorizontalAimer of(tt_OriginSource targetOriginSource, tt_PlayerSource playerSource)
  {
    let result = new("tt_HorizontalAimer");

    result._targetOriginSource = targetOriginSource;
    result._playerSource       = playerSource;

    return result;
  }

  override void changeWorld()
  {
    let targetOrigin = _targetOriginSource.getOrigin();
    if (targetOrigin == NULL) { return; }

    let pawn = _playerSource.getPawn();
    if (pawn == NULL) { return; }

    Vector3 myPosition    = pawn.pos;
    Vector3 otherPosition = targetOrigin.getVector();
    double  angle         = AngleTo(myPosition.XY, otherPosition.XY);

    pawn.A_SetAngle(angle, SPF_INTERPOLATE);
  }

  private static double AngleTo(Vector2 myPosition, Vector2 otherPosition)
  {
    Vector2 xy = otherPosition - myPosition;
    return VectorAngle(xy.x, xy.y);
  }

  private tt_OriginSource _targetOriginSource;
  private tt_PlayerSource _playerSource;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_HorizontalAimer";

  Array<tt_Origin> targetPositions;
  Array<double>    angles;

  targetPositions.push(tt_Origin.of(( 100,  100, 0))); angles.push(  45);
  targetPositions.push(tt_Origin.of((-100, -100, 0))); angles.push(-135);
  targetPositions.push(tt_Origin.of((   0,    0, 0))); angles.push(   0);

  players[consolePlayer].mo.SetOrigin((0, 0, 0), false);

  int nTargetPositions = targetPositions.size();
  for (int i = 0; i < nTargetPositions; ++i)
  {
    let    originSource  = tt_OriginSourceMock.of();
    let    playerSource  = tt_PlayerSourceMock.of();
    let    aimer         = tt_HorizontalAimer.of(originSource, playerSource);
    let    targetOrigin  = targetPositions[i];
    let    pawn          = players[consolePlayer].mo;
    double angle         = angles[i];

    originSource.expect_getOrigin(targetOrigin);
    playerSource.expect_getPawn(pawn);

    // Just for a visual check.
    spawn("DoomImp", targetOrigin.getVector());

    aimer.changeWorld();

    let message = string.format("%s: pawn is oriented at the target, angle: %f",
                                tag,
                                angle);
    it(message, AssertEval(pawn.angle, "~==", angles[i]));
    assertSatisfaction(originSource.getSatisfaction(), tag);
    assertSatisfaction(playerSource.getSatisfaction(), tag);

    cleanUpSpawned();
  }
}
#+end_src

** ~VerticalAimer~

#+begin_src c :tangle build/Typist.pk3/zscript/aimer/vertical_aimer.zs

// Implements tt_WorldChanger interface by adjusting the player pitch
// (horizontal angle). If autoaim is enabled, no pitch adjustment is done.
class tt_VerticalAimer : tt_WorldChanger
{
  static tt_VerticalAimer of(tt_OriginSource targetOriginSource,
                             tt_PlayerSource playerSource,
                             tt_Settings     settings)
  {
    let result = new("tt_VerticalAimer");

    result._targetOriginSource = targetOriginSource;
    result._playerSource       = playerSource;
    result._settings           = settings;

    return result;
  }

  override void changeWorld()
  {
    if (!isAutoaimEnabled())
    {
      setPitch();
    }
  }

  private play bool isAutoaimEnabled()
  {
    return _settings.isAutoaimEnabled();
  }

  private play void setPitch()
  {
    let targetOrigin = _targetOriginSource.getOrigin();
    if (targetOrigin == NULL) { return; }

    let pawn = _playerSource.getPawn();
    if (pawn == NULL) { return; }

    Vector3 myPosition = pawn.pos;
    myPosition.z += pawn.Height / 2 + pawn.AttackZOffset;

    Vector3 otherPosition = targetOrigin.getVector();
    Vector3 diff          = myPosition - otherPosition;
    double  angle         = Atan2(diff.z, sqrt(diff.x * diff.x + diff.y * diff.y));

    pawn.A_SetPitch(angle, SPF_INTERPOLATE);
  }

  private tt_OriginSource _targetOriginSource;
  private tt_PlayerSource _playerSource;
  private tt_Settings     _settings;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_VerticalAimer";
  let targetOriginSource = tt_OriginSourceMock.of();
  let playerSource       = tt_PlayerSourceMock.of();
  let settings           = tt_SettingsMock.of();

  let aimer = tt_VerticalAimer.of(targetOriginSource, playerSource, settings);

  let targetOrigin = tt_Origin.of((550, 500, 500));
  let pawn         = players[consolePlayer].mo;
  pawn.SetOrigin((0, 0, 0), false);

  targetOriginSource.expect_getOrigin(targetOrigin);
  playerSource      .expect_getPawn(pawn);
  settings          .expect_isAutoaimEnabled(false);

  aimer.changeWorld();

  assertSatisfaction(targetOriginSource.getSatisfaction(), tag);
  assertSatisfaction(playerSource.getSatisfaction(), tag);
  assertSatisfaction(settings.getSatisfaction(), tag);
}
#+end_src

* Answer

** ~Answer~

#+begin_src c :tangle build/Typist.pk3/zscript/answer/answer.zs

// Represents an answer to a tt_Question.
// See tt_Question.
class tt_Answer
{
  static tt_Answer of(String answer = "")
  {
    let result = new("tt_Answer");

    result._answer = answer;

    return result;
  }

  string getString() const
  {
    return _answer;
  }

  void append(String character)
  {
    _answer = _answer .. character;
  }

  void deleteLastCharacter()
  {
    _answer.DeleteLastCharacter();
  }

  private string _answer;
}
#+end_src

** ~AnswerSource~

#+begin_src c :tangle build/Typist.pk3/zscript/answer/answer_source.zs

// This interface represents a source of answers.
class tt_AnswerSource : tt_KeyProcessor abstract
{
  abstract tt_Answer getAnswer();

  // Clears answer.
  abstract void reset();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_AnswerSourceMock : tt_AnswerSource
{
  static tt_AnswerSourceMock of() { return new("tt_AnswerSourceMock"); }

  override tt_Answer getAnswer()
  {
    ++_mock_getAnswer_called;
    return _mock_getAnswer;
  }

  void expect_getAnswer(tt_Answer value, int expected = 1)
  {
    _mock_getAnswer = value;
    _mock_getAnswer_expected = expected;
    _mock_getAnswer_called = 0;
  }

  private tt_Answer _mock_getAnswer;
  private int _mock_getAnswer_expected;
  private int _mock_getAnswer_called;

  override void reset()
  {
    ++_mock_reset_called;
  }

  void expect_reset(int expected = 1)
  {
    _mock_reset_expected = expected;
    _mock_reset_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getAnswer",
            _mock_getAnswer_expected == _mock_getAnswer_called)
      .push(getClassName() .. ": reset",
            _mock_reset_expected == _mock_reset_called);
  }

  override void processKey(tt_Character character) {}

  private int _mock_reset_expected;
  private int _mock_reset_called;
}
#+end_src

** ~InputBlockAfterCombat~

#+begin_src c :tangle build/Typist.pk3/zscript/answer/input_block_after_combat.zs

// Implements tt_AnswerSource by taking another tt_AnswerSource,
// and only passing keys to it if a key was pressed down after the game mode
// has changed to Combat.
class tt_InputBlockAfterCombat : tt_AnswerSource
{
  static tt_InputBlockAfterCombat of(tt_AnswerSource answerSource,
                                     tt_ModeSource   modeSource,
                                     tt_ModeSource   oldModeSource)
  {
    let result = new("tt_InputBlockAfterCombat");

    result._answerSource  = answerSource;
    result._modeSource    = modeSource;
    result._oldModeSource = oldModeSource;

    result._isLocked = false;

    return result;
  }

  void update()
  {
    int mode    = _modeSource.getMode();
    int oldMode = _oldModeSource.getMode();

    if (oldMode != tt_Mode.Combat && mode == tt_Mode.Combat)
    {
      _isLocked = true;
    }
  }

  override tt_Answer getAnswer()
  {
    return _answerSource.getAnswer();
  }

  override void processKey(tt_Character character)
  {
    if (character.getEventType() == UiEvent.Type_KeyDown)
    {
      _isLocked = false;
    }

    if (!_isLocked)
    {
      _answerSource.processKey(character);
    }
  }

  override void reset() {}

  private tt_AnswerSource _answerSource;
  private tt_ModeSource   _modeSource;
  private tt_ModeSource   _oldModeSource;

  private bool _isLocked;
}
#+end_src

** ~PlayerInput~

#+begin_src c :tangle build/Typist.pk3/zscript/answer/player_input.zs

// Implements tt_AnswerSource by receiving player key inputs and
// composing an answer from them.
class tt_PlayerInput : tt_AnswerSource
{
  static tt_PlayerInput of(tt_ModeStorage      modeStorage,
                           tt_KeyPressReporter keyPressReporter)
  {
    let result = new("tt_PlayerInput");

    result._modeStorage      = modeStorage;
    result._keyPressReporter = keyPressReporter;

    result._answer = tt_Answer.of();

    return result;
  }

  override tt_Answer getAnswer()
  {
    return _answer;
  }

  override void processKey(tt_Character character)
  {
    int type = character.getType();
    switch (type)
    {
    case tt_Character.NONE: break;

    case tt_Character.PRINTABLE:
      _answer.append(character.getCharacter());
      _keyPressReporter.report();
      break;

    case tt_Character.BACKSPACE:      _answer.deleteLastCharacter();         break;
    case tt_Character.CTRL_BACKSPACE: reset();                               break;
    case tt_Character.ESCAPE:         _modeStorage.setMode(tt_Mode.Explore); break;
    }
  }

  override void reset()
  {
    _answer = tt_Answer.of();
  }

  private tt_ModeStorage      _modeStorage;
  private tt_KeyPressReporter _keyPressReporter;

  private tt_Answer _answer;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_PlayerInputTest: testPlayerInputCheckInput";
  let env = tt_PlayerInputTestEnvironment.of();

  string input = "abc";
  env.throwStringIntoInput(input);

  let answer       = env.playerInput.getAnswer();
  let answerString = answer.getString();

  it(tag .. ": input must be an answer", Assert(input == answerString));
}
{
  let tag = "tt_PlayerInputTest: testPlayerInputCheckReset";
  let env = tt_PlayerInputTestEnvironment.of();
  int TYPE_CHAR = UiEvent.Type_Char;

  string input1 = "abc";
  string input2 = "def";

  env.throwStringIntoInput(input1);
  let reset = tt_Character.of(TYPE_CHAR, tt_su_Ascii.BACKSPACE, true);
  env.playerInput.processKey(reset);
  env.throwStringIntoInput(input2);

  let answer       = env.playerInput.getAnswer();
  let answerString = answer.getString();

  it(tag .. ": second input must be an answer", Assert(input2 == answerString));
}
{
  let tag = "tt_PlayerInputTest: testBackspace";
  let env = tt_PlayerInputTestEnvironment.of();
  int TYPE_CHAR = UiEvent.Type_Char;

  let backspace = tt_Character.of(TYPE_CHAR, tt_su_Ascii.BACKSPACE, false);
  let letterA   = tt_Character.of(TYPE_CHAR, tt_su_Ascii.LATIN_SMALL_LETTER_A, false);

  //env.playerInput.reset();
  env.playerInput.processKey(backspace);
  env.playerInput.processKey(letterA);
  env.playerInput.processKey(backspace);
  env.playerInput.processKey(letterA);

  let answer       = env.playerInput.getAnswer();
  let answerString = answer.getString();

  it(tag .. ": input after backspace must be valid", Assert(answerString == "a"));
}
{
  let tag = "tt_PlayerInputTest: testCtrlBackspace";
  let env = tt_PlayerInputTestEnvironment.of();
  int TYPE_CHAR = UiEvent.Type_Char;

  let ctrlBackspace = tt_Character.of(TYPE_CHAR, tt_su_Ascii.BACKSPACE, true);
  let letterA   = tt_Character.of(TYPE_CHAR, tt_su_Ascii.LATIN_SMALL_LETTER_A, false);

  env.playerInput.processKey(letterA);
  env.playerInput.processKey(letterA);
  env.playerInput.processKey(ctrlBackspace);

  let answer       = env.playerInput.getAnswer();
  let answerString = answer.getString();

  it(tag .. ": input after ctrl-backspace must be empty", Assert(answerString == ""));
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_PlayerInputTestEnvironment
{
  static tt_PlayerInputTestEnvironment of()
  {
    let result = new("tt_PlayerInputTestEnvironment");
    result.modeStorage      = tt_ModeStorageMock.of();
    result.keyPressReporter = tt_KeyPressReporterMock.of();
    result.playerInput      = tt_PlayerInput.of(result.modeStorage,
                                                result.keyPressReporter);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return modeStorage.getSatisfaction().add(keyPressReporter.getSatisfaction());
  }

  void throwStringIntoInput(string str)
  {
    uint inputSize = str.length();
    for (uint i = 0; i < inputSize; ++i)
    {
      let character = tt_Character.of(TYPE_CHAR, str.ByteAt(i), false);
      playerInput.processKey(character);
    }

    let enter = tt_Character.of(TYPE_CHAR, tt_su_Ascii.CARRIAGE_RETURN_CR, false);
    playerInput.processKey(enter);
  }

  const TYPE_CHAR = UiEvent.Type_Char;

  tt_ModeStorageMock      modeStorage;
  tt_KeyPressReporterMock keyPressReporter;
  tt_PlayerInput          playerInput;
}
#+end_src

* Answer State

** ~AnswerState~

#+begin_src c :tangle build/Typist.pk3/zscript/answer_state/answer_state.zs

// Represents Answer state.
// See tt_Answer class.
class tt_AnswerState
{
  static tt_AnswerState of(int state)
  {
    let result = new("tt_AnswerState");
    result._state = state;
    return result;
  }

  enum _
  {
    Unknown,
    Preparing,
    Ready,
    Finished
  }

  bool isReady() const
  {
    return (_state >= Ready);
  }

  bool isFinished() const
  {
    return (_state == Finished);
  }

  bool isEqual(tt_AnswerState other)
  {
    return _state == other._state;
  }

  private int _state;
}
#+end_src

** ~AnswerStateSource~

#+begin_src c :tangle build/Typist.pk3/zscript/answer_state/answer_state_source.zs

// This interface provides access to tt_AnswerState.
class tt_AnswerStateSource : tt_KeyProcessor abstract
{
  abstract tt_AnswerState getAnswerState();

  abstract void reset();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_AnswerStateSourceMock : tt_AnswerStateSource
{
  static tt_AnswerStateSourceMock of() { return new("tt_AnswerStateSourceMock"); }

  override tt_AnswerState getAnswerState()
  {
    ++_mock_getAnswerState_called;
    return _mock_getAnswerState;
  }

  void expect_getAnswerState(tt_AnswerState value, int expected = 1)
  {
    _mock_getAnswerState = value;
    _mock_getAnswerState_expected = expected;
    _mock_getAnswerState_called = 0;
  }

  private tt_AnswerState _mock_getAnswerState;
  private int _mock_getAnswerState_expected;
  private int _mock_getAnswerState_called;

  override void reset()
  {
    ++_mock_reset_called;
  }

  void expect_reset(int expected = 1)
  {
    _mock_reset_expected = expected;
    _mock_reset_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getAnswerState",
            _mock_getAnswerState_expected == _mock_getAnswerState_called)
      .push(getClassName() .. " : reset",
            _mock_reset_expected == _mock_reset_called);
  }

  override void processKey(tt_Character character) {}

  private int _mock_reset_expected;
  private int _mock_reset_called;
}
#+end_src

** ~PressedAnswerState~

#+begin_src c :tangle build/Typist.pk3/zscript/answer_state/pressed_answer_state.zs

// Implements tt_AnswerState by observing Enter and Space keys.
//
// The state is:
// - Preparing when no Enter or Space key is pressed.
// - Ready when Enter or Space key is pressed, but not yet released.
// - Finished when Enter or Space key is released.
//
// Note: space acts the same as Enter key, see tt_Character class for details.
class tt_PressedAnswerState : tt_AnswerStateSource
{
  static tt_PressedAnswerState of()
  {
    let result = new("tt_PressedAnswerState");
    result._answerState = DEFAULT_STATE;
    return result;
  }

  override void processKey(tt_Character character)
  {
    switch (character.getType())
    {
    case tt_Character.ENTER:    _answerState = tt_AnswerState.Ready;     break;
    case tt_Character.ENTER_UP: _answerState = tt_AnswerState.Finished;  break;
    case tt_Character.NONE:     break;
    default:                    _answerState = tt_AnswerState.Preparing; break;
    }
  }

  override tt_AnswerState getAnswerState()
  {
    return tt_AnswerState.of(_answerState);
  }

  override void reset()
  {
    _answerState = DEFAULT_STATE;
  }

  const DEFAULT_STATE = tt_AnswerState.Preparing;

  private int _answerState;
}
#+end_src

* Character

** ~Character~

#+begin_src c :tangle build/Typist.pk3/zscript/character/character.zs

// Represents a character.
class tt_Character
{
  static tt_Character of(int type, int code, bool isCtrl)
  {
    let result = new("tt_Character");

    result._eventType = type;
    //Console.printf("type: %d, code: %d", type, code);

    // Normally, KeyUp events aren't registered, but releasing Enter or Space
    // key has special meaning, important for Hold Fire feature.
    if (type == UiEvent.Type_KeyUp &&
        (code == tt_su_Ascii.CARRIAGE_RETURN_CR || code == tt_su_Ascii.SPACE))
    {
      result._type = ENTER_UP;
      return result;
    }

    bool isChar    = (type == UiEvent.Type_Char);
    bool isDown    = (type == UiEvent.Type_KeyDown);
    bool isRepeat  = (type == UiEvent.Type_KeyRepeat);
    bool isControl = (code == tt_su_Ascii.BACKSPACE
                   || code == tt_su_Ascii.CARRIAGE_RETURN_CR
                   || code == tt_su_Ascii.SPACE
                   || code == tt_su_Ascii.ESCAPE);

    if (!isChar && !((isDown || isRepeat) && isControl))
    {
      result._type = NONE;
      return result;
    }

    if      (code == tt_su_Ascii.BACKSPACE)
      result._type = isCtrl ? CTRL_BACKSPACE : BACKSPACE;
    else if (code == tt_su_Ascii.DELETE)             result._type = CTRL_BACKSPACE;
    else if (code == tt_su_Ascii.CARRIAGE_RETURN_CR) result._type = ENTER;
    else if (code == tt_su_Ascii.SPACE)              result._type = ENTER;
    else if (code == tt_su_Ascii.ESCAPE)             result._type = ESCAPE;
    else if (code <  tt_su_Ascii.FIRST_PRINTABLE)    result._type = NONE;
    else
    {
      result._type      = PRINTABLE;
      result._character = string.format("%c", code);
    }

    return result;
  }

  enum _
  {
    NONE,
    PRINTABLE,
    BACKSPACE,
    CTRL_BACKSPACE,
    ENTER,
    ENTER_UP,
    ESCAPE,
  }

  int getType() const { return _type; }

  string getCharacter() const { return _character; }

  int getEventType() const { return _eventType; }

  private int    _type;
  private string _character;
  private int    _eventType;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.LATIN_SMALL_LETTER_A, false);
  it("tt_Character: Small character", Assert(c.getType() == tt_Character.PRINTABLE));
  it("tt_Character: Small character", Assert(c.getCharacter() == "a"));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.LATIN_CAPITAL_LETTER_A, false);
  it("tt_Character: Big character", Assert(c.getType() == tt_Character.PRINTABLE));
  it("tt_Character: Big character", Assert(c.getCharacter() == "A"));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.DIGIT_FOUR, false);
  it("tt_Character: Number", Assert(c.getType() == tt_Character.PRINTABLE));
  it("tt_Character: Number", Assert(c.getCharacter() == "4"));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.BACKSPACE, false);
  it("tt_Character: Backspace", Assert(c.getType() == tt_Character.BACKSPACE));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.CHARACTER_NULL, false);
  it("tt_Character: Non-printable", Assert(c.getType() == tt_Character.NONE));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.BACKSPACE, true);
  it( "tt_Character: Ctrl-Backspace",
     Assert(c.getType() == tt_Character.CTRL_BACKSPACE));
}
{
  int TYPE_CHAR = UiEvent.Type_Char;
  let c = tt_Character.of(TYPE_CHAR, tt_su_Ascii.CARRIAGE_RETURN_CR, true);
  it("tt_Character: Enter", Assert(c.getType() == tt_Character.ENTER));
}
#+end_src

* Clock

** ~Clock~

#+begin_src c :tangle build/Typist.pk3/zscript/clock/clock.zs

// Provides access to time.
class tt_Clock abstract
{
  // Provides access to getting points in time.
  // Returns a moment in time.
  abstract int getNow();

  // Provides a way to determine how many ticks passed since a moment in time.
  // moment: a moment in time, received from getNow().
  // Returns a number of ticks since  moment.
  abstract int since(int moment);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ClockMock : tt_Clock
{
  static tt_ClockMock of() { return new("tt_ClockMock"); }

  override int getNow()
  {
    ++_mock_getNow_called;
    return _mock_getNow;
  }

  void expect_getNow(int value, int expected = 1)
  {
    _mock_getNow = value;
    _mock_getNow_expected = expected;
    _mock_getNow_called = 0;
  }

  private int _mock_getNow;
  private int _mock_getNow_expected;
  private int _mock_getNow_called;

  override int since(int moment)
  {
    ++_mock_since_called;
    return _mock_since;
  }

  void expect_since(int value, int expected = 1)
  {
    _mock_since = value;
    _mock_since_expected = expected;
    _mock_since_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getNow",
            _mock_getNow_expected == _mock_getNow_called)
      .push(getClassName() .. ": since",
            _mock_since_expected == _mock_since_called);
  }

  private int _mock_since;
  private int _mock_since_expected;
  private int _mock_since_called;
}
#+end_src

** ~TotalClock~

#+begin_src c :tangle build/Typist.pk3/zscript/clock/total_clock.zs

// Implements tt_Clock by getting total time since game start.
class tt_TotalClock : tt_Clock
{
  static tt_TotalClock of()
  {
    let result = new("tt_TotalClock");
    return result;
  }

  override int getNow()
  {
    return Level.totalTime;
  }

  override int since(int moment)
  {
    return getNow() - moment;
  }
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let clock = tt_TotalClock.of();

  int now1 = clock.getNow();
  int now2 = clock.getNow();

  it("tt_TotalClock: now is now", AssertEval(now1, "==", now2));

  int duration = clock.since(now1);
  it("tt_TotalClock: no time passed", AssertEval(duration, "==", 0));
}
#+end_src

* EventHandler

** ~EventHandler~

#+begin_src c :tangle build/Typist.pk3/zscript/event_handler/event_handler.zs

// Entry point for Typist.pk3.
class tt_EventHandler : EventHandler
{
  override void worldTick()
  {
    _playerHandler.tick();
    _server.tick();
    self.IsUiProcessor = _playerHandler.isCapturingKeys();
  }

  override bool uiProcess(UiEvent event)
  {
    let character = tt_Character.of(event.type, event.keyChar, event.isCtrl);
    _playerHandler.processKey(character);

    return false;
  }

  override bool inputProcess(InputEvent event)
  {
    _playerHandler.processInput(event.type);
    return false;
  }

  override void playerEntered(PlayerEvent event)
  {
    if (gameState != GS_Level && gameState != GS_StartUp) return;

    self.RequireMouse = true;

    if (_server == NULL) _server = tt_Server.of();

    int playerNumber = event.playerNumber;

    _server.addPlayer(playerNumber);
    tt_GameTweaks.tweakPlayer(players[playerNumber]);

    if (playerNumber == consolePlayer)
      _playerHandler = tt_PlayerSupervisor.of(consolePlayer);
  }

  override void worldThingDied(WorldEvent event)
  {
    _playerHandler.reportDead(event.Thing);
  }

  override void worldLoaded(WorldEvent event)
  {
    bool isTitlemap = (level.mapName ~== "TITLEMAP");
    if (isTitlemap)
      destroy();
  }

  override void worldUnloaded(WorldEvent event)
  {
    self.IsUiProcessor = false;
  }

  override void renderOverlay(RenderEvent event)
  {
    _playerHandler.draw(event);
  }

  override void consoleProcess(ConsoleEvent event)
  {
    string command = event.Name;

    if (command.left(3) != "tt_") return;

    if      (command == "tt_unlock_mode"  ) _playerHandler.unlockMode();
    else if (command == "tt_force_combat" ) _playerHandler.forceCombat();
    else if (command == "tt_reset_targets") _playerHandler.reset(consolePlayer);
  }

  override void networkCommandProcess(NetworkCommand command)
  {
    if (command.command == "tt_target")
    {
      double x = command.readDouble();
      double y = command.readDouble();
      double z = command.readDouble();

      _server.react(command.player, (x, y, z));
    }
  }

  private tt_PlayerHandler _playerHandler;
  private tt_Server        _server;
}
#+end_src

* Event Reporters

** ~AnswerReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/answer_reporter.zs

// Interface for reporting answer matching events.
class tt_AnswerReporter abstract
{
  abstract void reportMatch();

  abstract void reportNotMatch();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_AnswerReporterMock : tt_AnswerReporter
{
  static tt_AnswerReporterMock of() { return new("tt_AnswerReporterMock"); }

  override void reportMatch()
  {
    ++_mock_reportMatch_called;
  }

  void expect_reportMatch(int expected = 1)
  {
    _mock_reportMatch_expected = expected;
    _mock_reportMatch_called = 0;
  }

  private int _mock_reportMatch_expected;
  private int _mock_reportMatch_called;

  override void reportNotMatch()
  {
    ++_mock_reportNotMatch_called;
  }

  void expect_reportNotMatch(int expected = 1)
  {
    _mock_reportNotMatch_expected = expected;
    _mock_reportNotMatch_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. "reportMatch",
            _mock_reportMatch_expected == _mock_reportMatch_called)
      .push(getClassName() .. "reportNotMatch",
            _mock_reportNotMatch_expected == _mock_reportNotMatch_called);
  }

  private int _mock_reportNotMatch_expected;
  private int _mock_reportNotMatch_called;
}
#+end_src

** ~KeyPressReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/key_press_reporter.zs

// Interface for reporting key press events.
class tt_KeyPressReporter abstract
{
  abstract void report();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_KeyPressReporterMock : tt_KeyPressReporter
{
  static tt_KeyPressReporterMock of() { return new("tt_KeyPressReporterMock"); }

  override void report()
  {
    ++_mock_report_called;
  }

  void expect_report(int expected = 1)
  {
    _mock_report_expected = expected;
    _mock_report_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": report",
            _mock_report_expected == _mock_report_called);
  }

  private int _mock_report_expected;
  private int _mock_report_called;
}
#+end_src

** ~ModeReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/mode_reporter.zs

// Interface for reporting mode change events.
class tt_ModeReporter abstract
{
  abstract void report(int mode);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ModeReporterMock : tt_ModeReporter
{
  static tt_ModeReporterMock of() { return new("tt_ModeReporterMock"); }

  override void report(int mode)
  {
    ++_mock_report_called;
  }

  void expect_report(int expected = 1)
  {
    _mock_report_expected = expected;
    _mock_report_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": report",
            _mock_report_expected == _mock_report_called);
  }

  private int _mock_report_expected;
  private int _mock_report_called;
}
#+end_src

** ~PlayerSoundPlayer~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/player_sound_player.zs

// Implements tt_SoundPlayer by playing sounds for a player.
// The sounds won't play if they are disabled in settings.
class tt_PlayerSoundPlayer : tt_SoundPlayer
{
  static tt_PlayerSoundPlayer of(tt_PlayerSource playerSource,
                                 tt_SoundSettings settings)
  {
    let result = new("tt_PlayerSoundPlayer");

    result._playerSource = playerSource;
    result._settings     = settings;

    return result;
  }

  override void playSound(String soundId)
  {
    if (isDisabled()) return;

    let player = _playerSource.getPawn();
    int theme  = _settings.getTheme();
    soundId.AppendFormat("%d", theme);

    player.A_StartSound(soundId, CHAN_AUTO, SOUND_FLAGS);
  }

  private bool isDisabled()
  {
    return (!_settings.isEnabled());
  }

  const SOUND_FLAGS = CHANF_UI | CHANF_OVERLAP | CHANF_LOCAL;

  private tt_PlayerSource  _playerSource;
  private tt_SoundSettings _settings;
}
#+end_src

** ~SoundAnswerReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/sound_answer_reporter.zs

// Implements tt_AnswerReporter by playing a sound.
class tt_SoundAnswerReporter : tt_AnswerReporter
{
  static tt_SoundAnswerReporter of(tt_SoundPlayer soundPlayer)
  {
    let result = new("tt_SoundAnswerReporter");
    result._soundPlayer = soundPlayer;
    return result;
  }

  override void reportMatch()
  {
    _soundPlayer.playSound("tt/match");
  }

  override void reportNotMatch()
  {
    _soundPlayer.playSound("tt/not-match");
  }

  private tt_SoundPlayer _soundPlayer;
}
#+end_src

** ~SoundKeyPressReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/sound_key_press_reporter.zs

// Implements tt_KeyPressReporter by playing a sound.
// The sound won't play if it's disabled in settings.
class tt_SoundKeyPressReporter : tt_KeyPressReporter
{
  static tt_SoundKeyPressReporter of(tt_SoundPlayer soundPlayer, tt_SoundSettings settings)
  {
    let result = new("tt_SoundKeyPressReporter");

    result._soundPlayer = soundPlayer;
    result._settings    = settings;

    return result;
  }

  override void report()
  {
    if (_settings.isTypingEnabled())
    {
      _soundPlayer.playSound("tt/click");
    }
  }

  private tt_SoundPlayer   _soundPlayer;
  private tt_SoundSettings _settings;
}
#+end_src

** ~SoundModeReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/sound_mode_reporter.zs

// Implements tt_ModeReporter by playing the corresponding sound for each mode.
class tt_SoundModeReporter : tt_ModeReporter
{
  static tt_SoundModeReporter of(tt_SoundPlayer soundPlayer)
  {
    let result = new("tt_SoundModeReporter");
    result._soundPlayer = soundPlayer;
    return result;
  }

  override void report(int mode)
  {
    switch (mode)
    {
    case tt_Mode.Unknown:
      Console.printf("%s: report: unknown mode!", getClassName());
      break;
    case tt_Mode.Combat:  _soundPlayer.playSound("tt/combat");  break;
    case tt_Mode.Explore: _soundPlayer.playSound("tt/explore"); break;
    case tt_Mode.None:    break;
    }
  }

  private tt_SoundPlayer _soundPlayer;
}
#+end_src

** ~SoundPlayer~

#+begin_src c :tangle build/Typist.pk3/zscript/event_reporters/sound_player.zs

// This is an interface for playing sounds.
class tt_SoundPlayer abstract
{
  abstract void playSound(String soundId);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_SoundPlayerMock : tt_SoundPlayer
{
  static tt_SoundPlayerMock of() { return new("tt_SoundPlayerMock"); }

  override void playSound(String soundId)
  {
    ++_mock_playSound_called;
  }

  void expect_playSound(int expected = 1)
  {
    _mock_playSound_expected = expected;
    _mock_playSound_called = 0;
  }

  private int _mock_playSound_expected;
  private int _mock_playSound_called;
}
#+end_src

* Firer

** ~FirerImpl~

#+begin_src c :tangle build/Typist.pk3/zscript/firer/firer_impl.zs

// Implements tt_WorldChanger by making the player pawn fire a shot.
class tt_Firer : tt_WorldChanger
{
  static tt_Firer of(tt_PlayerSource playerSource)
  {
    let result = new("tt_Firer");
    result._playerSource = playerSource;
    return result;
  }

  override void changeWorld()
  {
    let  playerInfo = _playerSource.getInfo();
    bool isReady    = isWeaponReady(playerInfo);

    if (isReady)
    {
      let   pawn = _playerSource.getPawn();
      State stat = NULL;
      playerInfo.cmd.buttons |= BT_ATTACK;
      pawn.FireWeapon(stat);
    }
  }

  private static bool isWeaponReady(PlayerInfo player)
  {
    bool isReady = (player.WeaponState & WF_WEAPONREADY)
      || (player.WeaponState & WF_WEAPONREADYALT)
      || player.attackDown;

    return isReady;
  }

  private tt_PlayerSource _playerSource;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let        tag          = "tt_Firer";
  let        playerSource = tt_PlayerSourceMock.of();
  let        firer        = tt_Firer.of(playerSource);
  PlayerInfo info         = players[consolePlayer];
  let        pawn         = info.mo;

  playerSource.expect_getInfo(info);
  playerSource.expect_getPawn(pawn);

  int nBullets = pawn.countInv("Clip");
  it(tag .. ": must be 50 bullets before firing", AssertEval(nBullets, "==", 50));

  firer.changeWorld();

  assertSatisfaction(playerSource.getSatisfaction(), tag);

  // Note: this relies on sv_fastweapons 2.
  nBullets = pawn.countInv("Clip");
  it(tag .. ": must spend 1 bullet after firing", AssertEval(nBullets, "==", 49));
}
#+end_src

* Game Tweaks

** ~GameTweaks~

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// Buddha

server bool tt_buddha_enabled = true;
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/game_tweaks/game_tweaks.zs

// Handles game tweaks.
class tt_GameTweaks play
{
  static void tweakPlayer(PlayerInfo player)
  {
    let pawn = player.mo;
    if (pawn == NULL) return;

    makeInvulnerable(pawn);
    increaseDamage(pawn);
    decreaseIncomingDamage(pawn);
    protectFromSelfDamage(pawn);
    disableSeekingMissiles(pawn);
  }

  // Still lose health down to 1 point.
  static private void makeInvulnerable(PlayerPawn pawn)
  {
    if (tt_buddha_enabled)
      pawn.giveInventory("tt_Buddha", 1);
  }

  static private void increaseDamage(PlayerPawn pawn)
  {
    double originalDamage = getDefaultByType(pawn.getClass()).damageMultiply;
    pawn.damageMultiply = originalDamage * 10;
  }

  static private void decreaseIncomingDamage(PlayerPawn pawn)
  {
    double originalFactor = getDefaultByType(pawn.getClass()).damageFactor;
    pawn.damageFactor = originalFactor / 2;
  }

  static private void protectFromSelfDamage(PlayerPawn pawn)
  {
    pawn.selfDamageFactor = 0;
  }

  static private void disableSeekingMissiles(PlayerPawn pawn)
  {
    pawn.bCantSeek = true;
  }
}
#+end_src

** ~Buddha~

#+begin_src c :tangle build/Typist.pk3/zscript/buddha/buddha.zs

class tt_Buddha : PowerBuddha
{
  Default
  {
    // https://zdoom.org/wiki/Powerup_properties
    Powerup.Duration 0x7FFFFFFD;
    +INVENTORY.UNDROPPABLE;
  }
}
#+end_src

* Input Manager

** ~InputByModeManager~

#+begin_src c :tangle build/Typist.pk3/zscript/input_manager/input_by_mode_manager.zs

// Implements tt_InputManager by examining the current and old Typist mode.
// Input is reset when the game mode is changed.
class tt_InputByModeManager : tt_InputManager
{
  static tt_InputByModeManager of(tt_ModeSource modeSource,
                                  tt_PlayerInput playerInput)
  {
    let result = new("tt_InputByModeManager");

    result._modeSource  = modeSource;
    result._playerInput = playerInput;

    result._oldMode = tt_Mode.Unknown;

    return result;
  }

  override void manageInput()
  {
    int  mode             = _modeSource.getMode();
    bool isCapturingKeys  = (mode == tt_Mode.Combat);
    bool wasCapturingKeys = (_oldMode != tt_Mode.Combat);

    if (wasCapturingKeys && isCapturingKeys == false)
    {
      _playerInput.reset();
    }

    _oldMode = mode;
  }

  override bool isCapturingKeys()
  {
    int mode = _modeSource.getMode();
    return (mode == tt_Mode.Combat);
  }

  private tt_ModeSource  _modeSource;
  private tt_PlayerInput _playerInput;

  private int _oldMode;
}
#+end_src

** ~PassThroughInputManager~

#+begin_src c :tangle build/Typist.pk3/zscript/input_manager/pass_through_input_manager.zs

// Doesn't capture keys when pass throug is set, otherwise acts as base.
class tt_PassThroughInputManager : tt_InputManager
{
  static tt_PassThroughInputManager of(tt_InputManager base)
  {
    let result = new("tt_PassThroughInputManager");
    result._base = base;
    result._passThrough = PassThroughDisabled;
    return result;
  }

  override void manageInput()
  {
    _base.manageInput();
  }

  override bool isCapturingKeys()
  {
    if (_passThrough != PassThroughDisabled) return false;

    return _base.isCapturingKeys();
  }

  void setPassThrough()
  {
    _passThrough = WaitingForKeyDown;
  }

  void processInput(int type)
  {
    switch (_passThrough)
    {
      case PassThroughDisabled:
        return;

      case WaitingForKeyDown:
        if (type == InputEvent.Type_KeyDown)
          _passThrough = WaitingForKeyUp;
        return;

      case WaitingForKeyUp:
        if (type == InputEvent.Type_KeyUp)
          _passThrough = PassThroughDisabled;
        return;
    }
  }

  private tt_InputManager _base;
  private int _passThrough;

  enum _
  {
    PassThroughDisabled,
    WaitingForKeyDown,
    WaitingForKeyUp
  }
}
#+end_src

** ~InputManager~

#+begin_src c :tangle build/Typist.pk3/zscript/input_manager/input_manager.zs

// Helps managing user input.
class tt_InputManager abstract
{
  abstract void manageInput();

  abstract bool isCapturingKeys();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_InputManagerMock : tt_InputManager
{
  static tt_InputManagerMock of() { return new("tt_InputManagerMock"); }

  override void manageInput()
  {
    ++_mock_manageInput_called;
  }

  void expect_manageInput(int expected = 1)
  {
    _mock_manageInput_expected = expected;
    _mock_manageInput_called = 0;
  }

  private int _mock_manageInput_expected;
  private int _mock_manageInput_called;

  override bool isCapturingKeys()
  {
    ++_mock_isCapturingKeys_called;
    return _mock_isCapturingKeys;
  }

  void expect_isCapturingKeys(bool value, int expected = 1)
  {
    _mock_isCapturingKeys = value;
    _mock_isCapturingKeys_expected = expected;
    _mock_isCapturingKeys_called = 0;
  }

  private bool _mock_isCapturingKeys;
  private int _mock_isCapturingKeys_expected;
  private int _mock_isCapturingKeys_called;
}
#+end_src

* Key Processor

** ~KeyProcessor~

#+begin_src c :tangle build/Typist.pk3/zscript/key_processor/key_processor.zs

// This interface represents an entity that processes input keys.
class tt_KeyProcessor abstract
{
  abstract void processKey(tt_Character character);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_KeyProcessorMock : tt_KeyProcessor
{
  static tt_KeyProcessorMock of() { return new("tt_KeyProcessorMock"); }

  override void processKey(tt_Character character)
  {
    ++_mock_processKey_called;
  }

  void expect_processKey(int expected = 1)
  {
    _mock_processKey_expected = expected;
    _mock_processKey_called = 0;
  }

  private int _mock_processKey_expected;
  private int _mock_processKey_called;
}
#+end_src

** ~KeyProcessors~

#+begin_src c :tangle build/Typist.pk3/zscript/key_processor/key_processors.zs

// Implements tt_KeyProcessor interface by calling several instances
// of tt_KeyProcessor.
class tt_KeyProcessors : tt_KeyProcessor
{
  static tt_KeyProcessors of(Array<tt_KeyProcessor> keyProcessors)
  {
    let result = new("tt_KeyProcessors");
    result._keyProcessors.copy(keyProcessors);
    return result;
  }

  override void processKey(tt_Character character)
  {
    foreach (keyProcessor : _keyProcessors)
      keyProcessor.processKey(character);
  }

  private Array<tt_KeyProcessor> _keyProcessors;
}
#+end_src

* Known Target

** ~KnownTarget~

#+begin_src c :tangle build/Typist.pk3/zscript/known_target/known_target.zs

// Represents a target that already has been seen and registered.
class tt_KnownTarget
{
  static tt_KnownTarget of(tt_Target target, tt_Question question)
  {
    let result = new("tt_KnownTarget");

    result._target   = target;
    result._question = question;

    return result;
  }

  tt_Target getTarget() const { return _target; }

  tt_Question getQuestion() const { return _question; }

  private tt_Target   _target;
  private tt_Question _question;
}
#+end_src

** ~KnownTargetSource~

#+begin_src c :tangle build/Typist.pk3/zscript/known_target/known_target_source.zs

// This interface represents a source of known targets.
// See tt_KnownTarget.
class tt_KnownTargetSource abstract
{
  // Returns the currently registered (known) targets.
  abstract tt_KnownTargets getTargets() const;

  // Returns true if there are no targets in this source.
  abstract bool isEmpty() const;
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_KnownTargetSourceMock : tt_KnownTargetSource
{
  static tt_KnownTargetSourceMock of() { return new("tt_KnownTargetSourceMock"); }

  override tt_KnownTargets getTargets()
  {
    ++_mock_getTargets_called;
    return _mock_getTargets;
  }

  void expect_getTargets(tt_KnownTargets value, int expected = 1)
  {
    _mock_getTargets = value;
    _mock_getTargets_expected = expected;
    _mock_getTargets_called = 0;
  }

  private tt_KnownTargets _mock_getTargets;
  private int _mock_getTargets_expected;
  private int _mock_getTargets_called;

  override bool isEmpty()
  {
    ++_mock_isEmpty_called;
    return _mock_isEmpty;
  }

  void expect_isEmpty(bool value, int expected = 1)
  {
    _mock_isEmpty = value;
    _mock_isEmpty_expected = expected;
    _mock_isEmpty_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": isEmpty",
            _mock_isEmpty_expected == _mock_isEmpty_called)
      .push(getClassName() .. ": getTargets",
            _mock_getTargets_expected == _mock_getTargets_called);
  }

  private bool _mock_isEmpty;
  private int _mock_isEmpty_expected;
  private int _mock_isEmpty_called;
}
#+end_src

** ~KnownTargetSourceCache~

#+begin_src c :tangle build/Typist.pk3/zscript/known_target/known_target_source_cache.zs

// Implements tt_KnownTargetSource by reading other
// tt_KnownTargetSource only if the data is stale.
class tt_KnownTargetSourceCache : tt_KnownTargetSource
{
  static tt_KnownTargetSourceCache of(tt_KnownTargetSource targetSource,
                                      tt_StaleMarker staleMarker)
  {
    let result = new("tt_KnownTargetSourceCache");

    result._targetSource = targetSource;
    result._staleMarker  = staleMarker;

    return result;
  }

  override tt_KnownTargets getTargets()
  {
    ensureUpdated();
    return _targets;
  }

  override bool isEmpty()
  {
    ensureUpdated();
    return (_targets.size() == 0);
  }

  private void ensureUpdated()
  {
    if (_staleMarker.isStale())
    {
      _targets = _targetSource.getTargets();
    }
  }

  private tt_KnownTargetSource _targetSource;
  private tt_StaleMarker       _staleMarker;

  private tt_KnownTargets _targets;
}
#+end_src

** ~KnownTargets~

#+begin_src c :tangle build/Typist.pk3/zscript/known_target/known_targets.zs

// Represents a list of known targets.
class tt_KnownTargets
{
  static tt_KnownTargets of()
  {
    let result = new("tt_KnownTargets");
    return result;
  }

  // Returns a target in this list.
  tt_KnownTarget at(uint index) const
  {
    return _targets[index];
  }

  // Returns a number of targets in this list.
  uint size() const
  {
    return _targets.size();
  }

  // Returns true if this target list contains a target with the specified id.
  bool contains(tt_Target target) const
  {
    return (find(target) != size());
  }

  tt_KnownTarget findTarget(tt_Target target) const
  {
    uint index = find(target);
    return (index == size()) ? NULL : at(index);
  }

  // Adds a target to this list.
  void add(tt_KnownTarget target)
  {
    _targets.push(target);
  }

  void addMany(tt_KnownTargets targets)
  {
    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      _targets.push(targets.at(i));
    }
  }

  // Removes a target from the list.
  // If the target is not in the list, does nothing.
  void remove(tt_Target target)
  {
    uint index = find(target);
    if (index != size()) { _targets.Delete(index); }
  }

  // Searches for a target with a particular id.
  // Returns index on success, the total number of targets on failure.
  private uint find(tt_Target target) const
  {
    uint nTargets = size();
    for (uint i = 0; i < nTargets; ++i)
    {
      if (_targets[i].getTarget().isEqual(target)) { return i; }
    }
    return nTargets;
  }

  private Array<tt_KnownTarget> _targets;
}
#+end_src

** ~TargetRegistry~

#+begin_src c :tangle build/Typist.pk3/zscript/known_target/target_registry.zs

// Implements tt_KnownTargetSource by reading from targets from
// tt_TargetSource, assigning them questions, and storing them.
//
// Deactivated targets are removed from storage.
class tt_TargetRegistry : tt_KnownTargetSource
{
  static tt_TargetRegistry of(tt_TargetSource targetSource,
                              tt_Lesson lesson,
                              tt_TargetSource disabledTargetSource)
  {
    let result = new("tt_TargetRegistry");

    result._targetSource         = targetSource;
    result._lesson       = lesson;
    result._disabledTargetSource = disabledTargetSource;

    result._registry = tt_KnownTargets.of();

    return result;
  }

  override tt_KnownTargets getTargets()
  {
    update();
    return _registry;
  }

  override bool isEmpty()
  {
    update();
    return (_registry.size() == 0);
  }

  private void update()
  {
    let newTargets = _targetSource.getTargets();
    merge(newTargets);

    let disabledTargets = _disabledTargetSource.getTargets();
    subtract(disabledTargets);

    pruneNulls();
  }

  // Adds targets that are not already registered to the registry.
  //
  // Given that tt_KnownTargets.contains() is O(n), this function is O(n^2).
  // Optimization possible.
  private void merge(tt_Targets targets)
  {
    uint nTargets        = targets.size();
    let  newKnownTargets = tt_KnownTargets.of();

    for (uint i = 0; i < nTargets; ++i)
    {
      let target   = targets.at(i);
      let existing = _registry.findTarget(target);

      if (existing == NULL)
      {
        let knownTarget = makeKnownTarget(target);

        if (knownTarget != NULL)
        {
          newKnownTargets.add(knownTarget);
        }
      }
    }

    _registry.addMany(newKnownTargets);
  }

  // Given that tt_KnownTargets.remove() is at least O(n), this function is
  // at least O(n^2).
  // Optimization possible.
  private void subtract(tt_Targets targets)
  {
    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      _registry.remove(targets.at(i));
    }
  }

  private tt_KnownTarget makeKnownTarget(tt_Target target) const
  {
    let question = _lesson.getQuestion();

    if (question == NULL)
    {
      return NULL;
    }

    let newKnownTarget = tt_KnownTarget.of(target, question);

    return newKnownTarget;
  }

  private void pruneNulls()
  {
    let pruned = tt_KnownTargets.of();

    uint nTargets = _registry.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      let target      = _registry.at(i).getTarget();
      let targetActor = target.getActor();

      if (targetActor != NULL)
      {
        pruned.add(_registry.at(i));
      }
    }

    _registry = pruned;
  }

  private tt_TargetSource   _targetSource;
  private tt_Lesson _lesson;
  private tt_TargetSource   _disabledTargetSource;

  private tt_KnownTargets _registry;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_TargetRegistry: emptyCheck";
  let env = tt_TargetRegistryTestEnvironment.of();

  env.targetSource        .expect_getTargets(tt_Targets.of());
  env.disabledTargetSource.expect_getTargets(tt_Targets.of());

  it(tag .. ": is empty", Assert(env.targetRegistry.isEmpty()));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_TargetRegistry: addCheck";
  let env = tt_TargetRegistryTestEnvironment.of();

  let target1 = tt_Target.of(spawn("Demon", (0, 0, 0)));
  let target2 = tt_Target.of(spawn("Demon", (0, 0, 0)));
  let targets = tt_Targets.of();
  targets.add(target1);
  targets.add(target2);

  env.targetSource.expect_getTargets(targets);
  env.disabledTargetSource.expect_getTargets(tt_Targets.of());
  env.lesson.expect_getQuestion(tt_QuestionMock.of(), 2);

  let knownTargets = env.targetRegistry.getTargets();

  it(tag .. ": is two targets", AssertEval(knownTargets.size(), "==", 2));

  assertSatisfaction(env.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_TargetRegistry: addExistingCheck";
  let env = tt_TargetRegistryTestEnvironment.of();

  // First, add a single target.
  let demon1  = spawn("Demon", (0, 0, 0));
  let target  = tt_Target.of(demon1);
  let targets = tt_Targets.of();
  targets.add(target);

  env.targetSource.expect_getTargets(targets);
  env.disabledTargetSource.expect_getTargets(tt_Targets.of());
  env.lesson.expect_getQuestion(tt_QuestionMock.of());

  let knownTargets = env.targetRegistry.getTargets();

  it(tag .. ": is one target", AssertEval(knownTargets.size(), "==", 1));

  assertSatisfaction(env.getSatisfaction(), tag);

  // Second, add the same target again. Only a single target must remain
  // registered.
  env.targetSource.expect_getTargets(targets);
  env.disabledTargetSource.expect_getTargets(tt_Targets.of());
  env.lesson.expect_getQuestion(NULL, 0);

  knownTargets = env.targetRegistry.getTargets();

  it(tag .. ": is one target", AssertEval(knownTargets.size(), "==", 1));

  assertSatisfaction(env.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_TargetRegistry: remove";
  let env = tt_TargetRegistryTestEnvironment.of();

  // First, add two targets.
  let demon1  = spawn("Demon", (0, 0, 0));
  let demon2  = spawn("Demon", (0, 0, 0));
  let target1 = tt_Target.of(demon1);
  let target2 = tt_Target.of(demon2);
  let targets = tt_Targets.of();
  targets.add(target1);
  targets.add(target2);

  env.targetSource.expect_getTargets(targets);
  env.disabledTargetSource.expect_getTargets(tt_Targets.of());
  env.lesson.expect_getQuestion(tt_QuestionMock.of(), 2);

  let knownTargets = env.targetRegistry.getTargets();

  it(tag .. ": is two targets", AssertEval(knownTargets.size(), "==", 2));

  assertSatisfaction(env.getSatisfaction(), tag);

  // Second, remove one target.
  let disabledTarget  = tt_Target.of(demon1);
  let disabledTargets = tt_Targets.of();
  disabledTargets.add(disabledTarget);

  env.targetSource.expect_getTargets(tt_Targets.of());
  env.disabledTargetSource.expect_getTargets(disabledTargets);
  env.lesson.expect_getQuestion(NULL, 0);

  knownTargets = env.targetRegistry.getTargets();

  it(tag .. ": is one target now", AssertEval(knownTargets.size(), "==", 1));

  assertSatisfaction(env.getSatisfaction(), tag);
  cleanUpSpawned();
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_TargetRegistryTestEnvironment
{
  static tt_TargetRegistryTestEnvironment of()
  {
    let result = new("tt_TargetRegistryTestEnvironment");
    result.targetSource         = tt_TargetSourceMock.of();
    result.lesson               = tt_LessonMock.of();
    result.disabledTargetSource = tt_TargetSourceMock.of();
    result.targetRegistry       = tt_TargetRegistry.of(result.targetSource,
                                                       result.lesson,
                                                       result.disabledTargetSource);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return targetSource.getSatisfaction()
      .add(lesson.getSatisfaction())
      .add(disabledTargetSource.getSatisfaction());
  }

  tt_TargetSourceMock   targetSource;
  tt_LessonMock lesson;
  tt_TargetSourceMock   disabledTargetSource;

  tt_KnownTargetSource  targetRegistry;
}
#+end_src

* Lesson

** ~Lesson~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/question_source.zs

// Interface for getting Questions.
// Different question sources are different Lessons.
class tt_Lesson abstract
{
  abstract tt_Question getQuestion();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_LessonMock : tt_Lesson
{
  static tt_LessonMock of() { return new("tt_LessonMock"); }

  override tt_Question getQuestion()
  {
    ++_mock_getQuestion_called;
    return _mock_getQuestion;
  }

  void expect_getQuestion(tt_Question value, int expected = 1)
  {
    _mock_getQuestion = value;
    _mock_getQuestion_expected = expected;
    _mock_getQuestion_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. "getQuestion",
            _mock_getQuestion_expected == _mock_getQuestion_called);
  }

  private tt_Question _mock_getQuestion;
  private int _mock_getQuestion_expected;
  private int _mock_getQuestion_called;
}
#+end_src

** ~MathsLesson~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/maths_lesson.zs

// Implements tt_Lesson by composing arithmetic tasks.
class tt_MathsLesson : tt_Lesson
{
  static tt_MathsLesson of()
  {
    let result = new("tt_MathsLesson");
    return result;
  }

  override tt_Question getQuestion()
  {
    int operation = random[typist](Addition, Division);

    switch (operation)
    {
    case Addition:       return makeAdditionQuestion();
    case Subtraction:    return makeSubtractionQuestion();
    case Multiplication: return makeMultiplicationQuestion();
    case Division:       return makeDivisionQuestion();
    }

    Console.printf("%s: getQuestion: unknown operation!", getClassName());
    return NULL;
  }

  private tt_Question makeAdditionQuestion()
  {
    int leftAddend  = random[typist](11, 49);
    int rightAddend = random[typist](11, 50);
    int sum         = leftAddend + rightAddend;

    string description = string.format("%d + %d", leftAddend,  rightAddend);
    string answer      = string.format("%d", sum);

    let question = tt_Match.of(answer, description);
    return question;
  }

  private tt_Question makeSubtractionQuestion()
  {
    int minuend    = random[typist](50, 99);
    int subtrahend = random[typist](11, 50);
    int difference = minuend - subtrahend;

    string description = string.format("%d - %d", minuend, subtrahend);
    string answer      = string.format("%d", difference);

    let question = tt_Match.of(answer, description);
    return question;
  }

  private tt_Question makeMultiplicationQuestion()
  {
    int multiplicand = random[typist](2, 9);
    int multiplier   = random[typist](2, 9);
    int product      = multiplicand * multiplier;

    string description = string.format("%d * %d", multiplicand, multiplier);
    string answer      = string.format("%d", product);

    let question = tt_Match.of(answer, description);
    return question;
  }

  private tt_Question makeDivisionQuestion()
  {
    int quotient = random[typist](2, 9);
    int divisor  = random[typist](2, 9);
    int dividend = quotient * divisor;

    string description = string.format("%d / %d", dividend, divisor);
    string answer      = string.format("%d", quotient);

    let question = tt_Match.of(answer, description);
    return question;
  }

  enum Operations
  {
    Addition,
    Subtraction,
    Multiplication,
    Division,
  }
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let question = tt_MathsLesson.of().getQuestion();
  let answer   = tt_Answer.of(question.getDescription());

  it("tt_MathsLesson: question isn't equal to the answer",
    AssertFalse(question.isRight(answer)));
}
#+end_src

** ~MixedLesson~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/mixed_lesson.zs

class tt_MixedLesson : tt_Lesson
{
  static tt_MixedLesson of(tt_Settings settings, Array<tt_Lesson> lessons)
  {
    let result = new("tt_MixedLesson");
    result._settings = settings;
    result._lessons.move(lessons);
    return result;
  }

  override tt_Question getQuestion()
  {
    readSettings();

    Array<tt_Lesson> enabledLessons;

    uint nLessons = _lessons.size();

    for (uint i = 0; i < nLessons; ++i)
    {
      if (_isLessonEnabled[i])
      {
        enabledLessons.push(_lessons[i]);
      }
    }

    uint nEnabledLessons = enabledLessons.size();
    if (nEnabledLessons == 0)
    {
      return NULL;
    }

    uint randomLessonIndex = random[typist](0, nEnabledLessons - 1);
    let  lesson    = enabledLessons[randomLessonIndex];
    let  question          = lesson.getQuestion();

    return question;
  }

  private void readSettings()
  {
    uint nLessons = _lessons.size();
    _isLessonEnabled.Resize(nLessons);

    for (uint i = 0; i < nLessons; ++i)
    {
      _isLessonEnabled[i] = _settings.getLessonEnabled(i);
    }
  }

  private tt_Settings _settings;

  private Array<tt_Lesson> _lessons;
  private Array<bool>      _isLessonEnabled;
}
#+end_src

** ~RandomCharactersLesson~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/random_characters_lesson.zs

// Implements tt_Lesson by composing a question from groups
// of characters enabled by settings.
class tt_RandomCharactersLesson : tt_Lesson
{
  static tt_RandomCharactersLesson of(tt_RandomCharactersLessonSettings settings)
  {
    let result = new("tt_RandomCharactersLesson");

    result._settings = settings;

    return result;
  }

  override tt_Question getQuestion()
  {
    string characters = composeCharacterRange();
    int    length     = _settings.getLessonLength();
    string picked     = pick(characters, length);
    let    question   = tt_Match.of(picked, picked);

    return question;
  }

  // This function is guaranteed to return non-empty strings.
  private string composeCharacterRange()
  {
    string characters;

    if (_settings.isUppercaseLettersEnabled()) { characters.AppendFormat("%s", UPPERCASE_LETTERS); }
    if (_settings.isLowercaseLettersEnabled()) { characters.AppendFormat("%s", LOWERCASE_LETTERS); }
    if (_settings.isNumbersEnabled         ()) { characters.AppendFormat("%s", NUMBERS          ); }
    if (_settings.isPunctuationEnabled     ()) { characters.AppendFormat("%s", PUNCTUATION      ); }
    if (_settings.isSymbolsEnabled         ())
    {
      // GZDoom cannot handle "\\" in a string, so add it manually.
      characters.AppendFormat("%s%c", SYMBOLS, tt_su_Ascii.REVERSE_SOLIDUS);
    }
    if (_settings.isCustomCharactersEnabled())
    {
      characters.AppendFormat("%s", _settings.getCustomCharacters());
    }

    if (characters.Length() == 0)
    {
      characters = "?";
    }

    return characters;
  }

  // This function expects that characters consist of ASCII characters only.
  // This function is guaranteed to return non-empty strings.
  private static string pick(String characters, int number)
  {
    string picked;
    int    lastCharacter = characters.CodePointCount() - 1;

    for (int i = 0; i < number; ++i)
    {
      int randomIndex = random[typist](0, lastCharacter);
      int character   = getCodePointAt(characters, randomIndex);

      picked.AppendFormat("%c", character);
    }

    return picked;
  }

  // Attention! O(n)
  private static int getCodePointAt(String str, int index)
  {
    int letterCode;
    int charPos = 0;
    for (int i = 0; i <= index; ++i)
    {
      [letterCode, charPos] = str.GetNextCodePoint(charPos);
    }

    return letterCode;
  }

  const LOWERCASE_LETTERS = "abcdefghijklmnopqrstuvwxyz";
  const UPPERCASE_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const NUMBERS           = "0123456789";
  const PUNCTUATION       = ",.();:-'\"?!/";
  const SYMBOLS           = "~`@#$%^&*+=[]{}<>|";

  private tt_RandomCharactersLessonSettings _settings;
}
#+end_src

** ~RandomNumberSource~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/random_number_source.zs

// Implements tt_Lesson by producing questions that contain
// string composed from random numbers and should match exactly to the answers.
class tt_RandomNumberSource : tt_Lesson
{
  static tt_RandomNumberSource of()
  {
    let result = new("tt_RandomNumberSource");
    return result;
  }

  override tt_Question getQuestion()
  {
    let stringLength = 3;
    let str          = "";

    for (int i = 0; i < stringLength; ++i)
    {
      int number = random[typist](tt_su_Ascii.DIGIT_ZERO, tt_su_Ascii.DIGIT_NINE);
      str.AppendFormat("%c", number);
    }

    let question = tt_Match.of(str, str);

    return question;
  }
}
#+end_src

** ~SelectedLesson~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/selected_question_source.zs

// Implements tt_Lesson by selecting a question source
// according to the index from settings.
class tt_SelectedLesson : tt_Lesson
{
  static tt_SelectedLesson of(tt_Settings settings, Array<tt_Lesson> lessons)
  {
    let result = new("tt_SelectedLesson");
    result._settings = settings;
    result._lessons.move(lessons);
    return result;
  }

  override tt_Question getQuestion()
  {
    int lessonIndex = _settings.getLessonIndex();

    if (lessonIndex >= _lessons.size()) return NULL;

    return _lessons[lessonIndex].getQuestion();
  }

  private tt_Settings              _settings;
  private Array<tt_Lesson> _lessons;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_SelectedLesson: checkEmpty";
  Array<tt_Lesson> lessons;
  let env = tt_SelectedLessonTestEnvironment.of(lessons);

  env.settings.expect_getLessonIndex(0);

  let question = env.selectedLesson.getQuestion();

  it(tag .. ": no sources -> NULL question", AssertNull(question));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_SelectedLesson: checkTwo";
  let lesson1 = tt_LessonMock.of();
  let lesson2 = tt_LessonMock.of();
  Array<tt_Lesson> lessons = {lesson1, lesson2};
  let env = tt_SelectedLessonTestEnvironment.of(lessons);

  let mockQuestion = tt_QuestionMock.of();
  lesson2.expect_getQuestion(mockQuestion);
  env.settings   .expect_getLessonIndex(1);

  let question = env.selectedLesson.getQuestion();

  assertSatisfaction(lesson2.getSatisfaction(), tag);
  it(tag .. ": there are sources -> not NULL question",
     Assert(question == mockQuestion));
  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_SelectedLessonTestEnvironment
{
  static tt_SelectedLessonTestEnvironment of(Array<tt_Lesson> lessons)
  {
    let result = new("tt_SelectedLessonTestEnvironment");
    result.settings       = tt_SettingsMock.of();
    result.selectedLesson = tt_SelectedLesson.of(result.settings, lessons);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return settings.getSatisfaction();
  }

  tt_SettingsMock settings;
  tt_SelectedLesson selectedLesson;
}
#+end_src

** ~StringSet~

#+begin_src c :tangle build/Typist.pk3/zscript/lesson/string_set.zs

// Implements tt_Lesson by reading a lump with words and
// randomly selecting words from this lump.
class tt_StringSet : tt_Lesson
{
  static tt_StringSet of(String lumpName)
  {
    int    lump     = Wads.findLump(lumpName, 0, Wads.AnyNamespace);
    string contents = Wads.readLump(lump);
    Array<string> words;
    tt_su_su.splitByWords(contents, words);

    Array<string> filteredWords;
    filterWords(words, filteredWords);

    let result = new("tt_StringSet");

    result._lumpName = lumpName;
    result._words.move(filteredWords);

    return result;
  }

  override tt_Question getQuestion()
  {
    int nWords = int(_words.size());
    if (nWords == 0)
    {
      Console.printf("%s: getQuestion: no words in lump %s.",
                     getClassName(),
                     _lumpName);
      return NULL;
    }

    int    wordIndex = random[typist](0, nWords - 1);
    string word      = _words[wordIndex];
    let    question  = tt_Match.of(word, word);

    return question;
  }

  // Removes too short words, removes duplicates.
  // Guarantees that the result has at least one word.
  private static void filterWords(Array<String> input, out Array<String> result)
  {
    // Use map to remove duplicates.
    Map<string, int> wordSet;

    foreach (word : input)
    {
      if (word.codePointCount() > 1)
        wordSet.insert(word, 0);
    }

    foreach (word, value : wordSet)
      result.push(word);

    if (result.size() == 0)
      result.push("<no words found>");
  }

  private string        _lumpName;
  private Array<string> _words;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let    stringSet   = tt_StringSet.of("tt_test_words");
  let    question    = stringSet.getQuestion();
  string description = question.getDescription();

  it("tt_StringSet: Question must be valid", AssertNotNull(question));
  it("tt_StringSet: Description", Assert(description == "Ð¿ÑÐ¸Ð²ÐµÑ"));
}
#+end_src

#+begin_src text :tangle build/Typist.pk3Test/tt_test_words.txt
  Ð¿ÑÐ¸Ð²ÐµÑ

#+end_src

* Math

#+begin_src c :tangle build/Typist.pk3/zscript/math/math.zs

// Namespace for math-related functions.
class tt_Math
{
  static bool isInEffectiveRange(Vector3 p1, Vector3 p2)
  {
    double distance = (p1 - p2).length();
    bool   inRange  = distance < MAX_DISTANCE;

    return inRange;
  }

  static Vector3 crossProduct(Vector3 u, Vector3 v)
  {
    Vector3 result;
    result.x = u.y * v.z - u.z * v.y;
    result.y = u.z * v.x - u.x * v.z;
    result.z = u.x * v.y - u.y * v.x;
    return result;
  }

  // Max effective distance.
  const MAX_DISTANCE = 700;
}
#+end_src

* Mode

** ~AutoModeSource~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/auto_mode_source.zs

// Implements tt_ModeSource by examining the specified tt_KnownTargetSource.
class tt_AutoModeSource : tt_ModeSource
{
  static tt_AutoModeSource of(tt_KnownTargetSource knownTargetSource,
                              tt_PlayerSource playerSource)
  {
    let result = new("tt_AutoModeSource");

    result._knownTargetSource = knownTargetSource;
    result._playerSource      = playerSource;

    return result;
  }

  override int getMode()
  {
    if (_knownTargetSource.isEmpty())
    {
      return tt_Mode.Explore;
    }

    bool isAtLeastOneVisible = false;
    let  pawn = _playerSource.getPawn();

    let  targets  = _knownTargetSource.getTargets();
    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      let target = targets.at(i).getTarget();
      if (isVisible(target, pawn))
      {
        isAtLeastOneVisible = true;
      }
    }

    int mode = (isAtLeastOneVisible ? tt_Mode.Combat : tt_Mode.Explore);

    return mode;
  }

  // Play-const hack: Actor.isVisible(...) is not const, but should be.
  private play bool isVisible(tt_Target target, PlayerPawn pawn) const
  {
    return pawn.isVisible(target.getActor(), ALL_AROUND);
  }

  const ALL_AROUND = 1; // true

  private tt_KnownTargetSource _knownTargetSource;
  private tt_PlayerSource      _playerSource;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_AutoModeSource: checkTargetsAreVisible";
  let env = tt_AutoModeSourceTestEnvironment.of();

  env.knownTargetSource.expect_isEmpty(true);

  int mode = env.autoModeSource.getMode();

  it(tag .. ": no targets -> Explore", AssertEval(mode, "==", tt_Mode.Explore));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_AutoModeSource: checkTargetsAreVisible";
  let env = tt_AutoModeSourceTestEnvironment.of();

  let knownTargets = tt_KnownTargets.of();
  let target       = tt_Target.of(spawn("Demon", (0, 0, 0)));
  let question     = tt_QuestionMock.of();
  let knownTarget  = tt_KnownTarget.of(target, question);
  knownTargets.add(knownTarget);

  env.knownTargetSource.expect_isEmpty(false);
  env.knownTargetSource.expect_getTargets(knownTargets);
  env.playerSource     .expect_getPawn(players[consolePlayer].mo);

  int mode = env.autoModeSource.getMode();

  it(tag .. ": there are visible targets -> Combat",
     AssertEval(mode, "==", tt_Mode.Combat));

  assertSatisfaction(env.getSatisfaction(), tag);

  cleanUpSpawned();
}
{
  let tag = "tt_AutoModeSource: checkTargetsAreInvisible";
  let env = tt_AutoModeSourceTestEnvironment.of();

  let knownTargets = tt_KnownTargets.of();
  let target       = tt_Target.of(spawn("Demon", (9999999, 0, 0)));
  let question     = tt_QuestionMock.of();
  let knownTarget  = tt_KnownTarget.of(target, question);
  knownTargets.add(knownTarget);

  env.knownTargetSource.expect_isEmpty(false);
  env.knownTargetSource.expect_getTargets(knownTargets);
  env.playerSource     .expect_getPawn(players[consolePlayer].mo);

  int mode = env.autoModeSource.getMode();

  it(tag .. ": There are no visible targets -> Explore",
     AssertEval(mode, "==", tt_Mode.Explore));

  assertSatisfaction(env.getSatisfaction(), tag);

  cleanUpSpawned();
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_AutoModeSourceTestEnvironment
{
  static tt_AutoModeSourceTestEnvironment of()
  {
    let result = new("tt_AutoModeSourceTestEnvironment");
    result.knownTargetSource = tt_KnownTargetSourceMock.of();
    result.playerSource      = tt_PlayerSourceMock.of();
    result.autoModeSource    =
      tt_AutoModeSource.of(result.knownTargetSource, result.playerSource);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return knownTargetSource.getSatisfaction().add(playerSource.getSatisfaction());
  }

  tt_KnownTargetSourceMock knownTargetSource;
  tt_PlayerSourceMock      playerSource;
  tt_AutoModeSource        autoModeSource;
}
#+end_src

** ~DelayedCombatModeSource~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/delayed_combat_mode_source.zs

// Implements tt_ModeSource by reading other tt_ModeSource, and switching to
// Exploration mode only if some time has passed or there is no enemies around.
class tt_DelayedCombatModeSource : tt_ModeSource
{
  static tt_DelayedCombatModeSource of(tt_Clock        clock,
                                       tt_ModeSource   modeSource,
                                       tt_TargetSource targetSource)
  {
    let result = new("tt_DelayedCombatModeSource");

    result._clock        = clock;
    result._modeSource   = modeSource;
    result._targetSource = targetSource;

    result._switchDetected = false;
    result._oldMode        = tt_Mode.None;
    result._switchToExploreMoment = 0;

    return result;
  }

  override int getMode()
  {
    int topMode = _modeSource.getMode();

    if (topMode != tt_Mode.Explore)
    {
      // let others decide.
      _oldMode = topMode;
      return tt_Mode.None;
    }

    bool wasCombat        = _oldMode == tt_Mode.Combat;
    bool isExplore        =  topMode == tt_Mode.Explore;
    bool areEnemiesAround = !_targetSource.getTargets().isEmpty();

    if (wasCombat && isExplore && areEnemiesAround)
    {
      _switchDetected        = true;
      _switchToExploreMoment = _clock.getNow();
    }

    _oldMode = topMode;

    if (!_switchDetected)
    {
      return tt_Mode.None;
    }

    bool timeIsUp = _clock.since(_switchToExploreMoment) > DELAY;

    if (timeIsUp)
    {
      _switchDetected = false;
    }

    return timeIsUp ? tt_Mode.None : tt_Mode.Combat;
  }

  const DELAY = TICRATE * 1; // 1 second

  private tt_Clock        _clock;
  private tt_ModeSource   _modeSource;
  private tt_TargetSource _targetSource;

  private int _switchDetected;
  private int _oldMode;
  private int _switchToExploreMoment;
}
#+end_src

#+begin_src c :noweb-ref test-body

// C - Combat Mode
// E - Exploration Mode
// N - None Mode (let other decide)
//
// |-----|-----|---------|-------------|--------|-------------------------|
// | old | new | enemies | time is up? | result | test                    |
// |-----|-----|---------|-------------|--------|-------------------------|
// |  *  |  C  |    *    |      *      | None   | checkNewCombat          |
// |  C  |  E  |   no    |      *      | None   | checkNoEnemies          |
// |  C  |  E  |   yes   |     no      | Combat | checkEnemiesStillCombat |
// |  C  |  E  |   yes   |     yes     | None   | checkEnemiesTimeIsUp    |
// |  E  |  *  |    *    |      *      | None   | checkOldExploration     |
// |-----|-----|---------|-------------|--------|-------------------------|
{
  let tag = "tt_DelayedCombatModeSource: checkNewCombat";
  let env = tt_DelayedCombatModeSourceTestEnvironment.of();

  env.modeSource.expect_getMode(tt_Mode.Combat, 2);
  env.clock.expect_getNow(0, 0);
  env.clock.expect_since(0, 0);

  int result1 = env.delay.getMode();
  it(tag .. ": new combat -> None", AssertEval(result1, "==", tt_Mode.None));

  int result2 = env.delay.getMode();
  it(tag .. ": again, combat -> None", AssertEval(result2, "==", tt_Mode.None));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_DelayedCombatModeSource: checkNoEnemies";
  let env = tt_DelayedCombatModeSourceTestEnvironment.of();

  // set up history: it was combat.
  env.modeSource.expect_getMode(tt_Mode.Combat);
  env.delay.getMode();

  env.modeSource.expect_getMode(tt_Mode.Explore);
  env.targetSource.expect_getTargets(tt_Targets.of());

  int result = env.delay.getMode();
  it(tag .. ": no enemies", AssertEval(result, "==", tt_Mode.None));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_DelayedCombatModeSource: checkEnemiesStillCombat";
  let env = tt_DelayedCombatModeSourceTestEnvironment.of();

  // set up history: it was combat.
  env.modeSource.expect_getMode(tt_Mode.Combat);
  env.delay.getMode();

  { // set expectations
    env.modeSource.expect_getMode(tt_Mode.Explore);

    let targets = tt_Targets.of();
    targets.add(NULL);
    env.targetSource.expect_getTargets(targets);

    env.clock.expect_getNow(0);
    env.clock.expect_since(0);
  }

  int result = env.delay.getMode();
  it(tag .. ": still combat", AssertEval(result, "==", tt_Mode.Combat));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_DelayedCombatModeSource: checkEnemiesTimeIsUp";
  let env = tt_DelayedCombatModeSourceTestEnvironment.of();

  // set up history: it was combat.
  env.modeSource.expect_getMode(tt_Mode.Combat);
  env.delay.getMode();

  { // set expectations
    env.modeSource.expect_getMode(tt_Mode.Explore);

    let targets = tt_Targets.of();
    targets.add(NULL);
    env.targetSource.expect_getTargets(targets);

    env.clock.expect_getNow(0);
    env.clock.expect_since(999);
  }

  int result = env.delay.getMode();
  it(tag .. ": no more combat", AssertEval(result, "==", tt_Mode.None));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_DelayedCombatModeSource: checkOldExploration";
  let env = tt_DelayedCombatModeSourceTestEnvironment.of();

  env.modeSource.expect_getMode(tt_Mode.Explore, 2);
  env.clock.expect_getNow(0, 0);
  env.clock.expect_since(0, 0);
  env.targetSource.expect_getTargets(tt_Targets.of(), 2);

  int result1 = env.delay.getMode();
  it(tag .. ": old Exploration -> None", AssertEval(result1, "==", tt_Mode.None));

  int result2 = env.delay.getMode();
  it(tag .. ": again, old Exploration -> None",
    AssertEval(result2, "==", tt_Mode.None));

  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_DelayedCombatModeSourceTestEnvironment
{
  static tt_DelayedCombatModeSourceTestEnvironment of()
  {
    let result = new("tt_DelayedCombatModeSourceTestEnvironment");
    result.clock        = tt_ClockMock.of();
    result.modeSource   = tt_ModeSourceMock.of();
    result.targetSource = tt_TargetSourceMock.of();

    result.delay        = tt_DelayedCombatModeSource.of(result.clock,
                                                        result.modeSource,
                                                        result.targetSource);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return clock.getSatisfaction()
      .add(modeSource.getSatisfaction())
      .add(targetSource.getSatisfaction());
  }

  tt_ClockMock        clock;
  tt_ModeSourceMock   modeSource;
  tt_TargetSourceMock targetSource;

  tt_DelayedCombatModeSource delay;
}
#+end_src

** ~Mode~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/mode.zs

// Represents the mode in which Typist operates.
class tt_Mode
{
  enum _
  {
    Unknown, // Should never be used. Only for detecting uninitialized variables.
    Combat,  // Typist is focused on destroying the targets.
    Explore, // Typist is focused on movement and exploration.
    None,    // None of the above.
  }
}
#+end_src

** ~ModeCascade~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/mode_cascade.zs

// Implements ModeSource by taking the first mode from ModeSources
// list that is not NONE.
class tt_ModeCascade : tt_ModeSource
{
  static tt_ModeCascade of(Array<tt_ModeSource> modeSources)
  {
    let result = new("tt_ModeCascade");
    result._modeSources.copy(modeSources);
    return result;
  }

  override int getMode()
  {
    foreach (source : _modeSources)
    {
      int mode = source.getMode();
      if (mode != tt_Mode.None) return mode;
    }

    return tt_Mode.None;
  }

  private Array<tt_ModeSource> _modeSources;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  Array<tt_ModeSource> sources;
  let cascade = tt_ModeCascade.of(sources);

  int mode = cascade.getMode();

  it("tt_ModeCascade: check zero sources: No source -> no mode",
     AssertEval(mode, "==", tt_Mode.None));
}
{
  let source1 = tt_ModeSourceMock.of();
  let source2 = tt_ModeSourceMock.of();
  Array<tt_ModeSource> sources = {source1, source2};

  let cascade = tt_ModeCascade.of(sources);

  source1.expect_getMode(tt_Mode.Explore);
  source2.expect_getMode(tt_Mode.Combat);

  int mode = cascade.getMode();

  it("tt_ModeCascade: check cascade first: Must be the first mode",
     AssertEval(mode, "==", tt_Mode.Explore));
}
{
  let source1 = tt_ModeSourceMock.of();
  let source2 = tt_ModeSourceMock.of();
  Array<tt_ModeSource> sources = {source1, source2};

  let cascade = tt_ModeCascade.of(sources);

  source1.expect_getMode(tt_Mode.None);
  source2.expect_getMode(tt_Mode.Combat);

  int mode = cascade.getMode();

  it("tt_ModeCascade: check cascade second: Must be the second mode",
     AssertEval(mode, "==", tt_Mode.Combat));
}
#+end_src

** ~ModeSource~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/mode_source.zs

// This interface represents a source of modes.
// See: tt_Mode.
class tt_ModeSource abstract
{
  abstract int getMode();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ModeSourceMock : tt_ModeSource
{
  static tt_ModeSourceMock of() { return new("tt_ModeSourceMock"); }

  override int getMode()
  {
    ++_mock_getMode_called;
    return _mock_getMode;
  }

  void expect_getMode(int value, int expected = 1)
  {
    _mock_getMode = value;
    _mock_getMode_expected = expected;
    _mock_getMode_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getMode",
            _mock_getMode_expected == _mock_getMode_called);
  }

  private int _mock_getMode;
  private int _mock_getMode_expected;
  private int _mock_getMode_called;
}
#+end_src

** ~ModeStorage~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/mode_storage.zs

// This is an interface for storing and retrieving mode.
class tt_ModeStorage : tt_ModeSource abstract
{
  abstract void setMode(int mode);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ModeStorageMock : tt_ModeStorage
{
  static tt_ModeStorageMock of() { return new("tt_ModeStorageMock"); }

  override void setMode(int mode)
  {
    ++_mock_setMode_called;
  }

  void expect_setMode(int expected = 1)
  {
    _mock_setMode_expected = expected;
    _mock_setMode_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": setMode",
            _mock_setMode_expected == _mock_setMode_called);
  }

  override int getMode() { return tt_Mode.None; }

  private int _mock_setMode_expected;
  private int _mock_setMode_called;
}
#+end_src

** ~ReportedModeSource~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/reported_mode_source.zs

// Implements tt_ModeSource by reading other mode source, and
// reporting an event when the mode has changed.
class tt_ReportedModeSource : tt_ModeSource
{
  static tt_ReportedModeSource of(tt_ModeReporter reporter, tt_ModeSource modeSource)
  {
    let result = new("tt_ReportedModeSource");

    result._reporter   = reporter;
    result._modeSource = modeSource;

    result._oldMode = tt_Mode.None;

    return result;
  }

  override int getMode()
  {
    int newMode = _modeSource.getMode();

    if (newMode != _oldMode)
    {
      if (_oldMode != tt_Mode.None)
      {
        _reporter.report(newMode);
      }

      _oldMode = newMode;
    }

    return newMode;
  }

  private tt_ModeReporter _reporter;
  private tt_ModeSource   _modeSource;

  private int _oldMode;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_ReportedModeSource: checkInitial";
  let env = tt_ReportedModeSourceTestEnvironment.of();

  int expected = tt_Mode.Explore;
  env.modeSource.expect_getMode(expected);

  int mode = env.reportedMode.getMode();

  it(tag .. ": explore after init", AssertEval(mode, "==", expected));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_ReportedModeSource: checkExplorationToCombat";
  let env = tt_ReportedModeSourceTestEnvironment.of();

  env.reporter.expect_report();

  env.modeSource.expect_getMode(tt_Mode.Explore);
  int mode1 = env.reportedMode.getMode();

  env.modeSource.expect_getMode(tt_Mode.Combat);
  int mode2 = env.reportedMode.getMode();

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_ReportedModeSource: checkCombatToExploration";
  let env = tt_ReportedModeSourceTestEnvironment.of();

  env.reporter.expect_report();

  env.modeSource.expect_getMode(tt_Mode.Combat);
  int mode1 = env.reportedMode.getMode();

  env.modeSource.expect_getMode(tt_Mode.Explore);
  int mode2 = env.reportedMode.getMode();

  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_ReportedModeSourceTestEnvironment
{
  static tt_ReportedModeSourceTestEnvironment of()
  {
    let result = new("tt_ReportedModeSourceTestEnvironment");
    result.reporter     = tt_ModeReporterMock.of();
    result.modeSource   = tt_ModeSourceMock.of();
    result.reportedMode = tt_ReportedModeSource.of(result.reporter,
                                                   result.modeSource);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return reporter.getSatisfaction().add(modeSource.getSatisfaction());
  }

  tt_ModeReporterMock   reporter;
  tt_ModeSourceMock     modeSource;
  tt_ReportedModeSource reportedMode;
}
#+end_src

** ~SettableMode~

#+begin_src c :tangle build/Typist.pk3/zscript/mode/settable_mode.zs

// Implements ModeStorage by simply storing the mode that was set.
class tt_SettableMode : tt_ModeStorage
{
  static tt_SettableMode of()
  {
    let result = new("tt_SettableMode");

    result._mode = tt_Mode.None;

    return result;
  }

  override int getMode()
  {
    return _mode;
  }

  override void setMode(int mode)
  {
    _mode = mode;
  }

  private int _mode;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let settableMode = tt_SettableMode.of();
  int before       = tt_Mode.Combat;

  settableMode.setMode(before);
  int after = settableMode.getMode();

  it("tt_SettableMode: mode must be the same", AssertEval(before, "==", after));
}
#+end_src

* Origin

** ~HastyQuestionAnswerMatcher~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/hasty_question_answer_matcher.zs

// Implements OriginSource by finding an origin for a known target
// that fits to for the answer.
class tt_HastyQuestionAnswerMatcher : tt_OriginSource
{
  static tt_HastyQuestionAnswerMatcher of(tt_KnownTargetSource knownTargetSource,
                                          tt_AnswerSource      answerSource,
                                          tt_PlayerSource      playerSource,
                                          tt_AnswerReporter    reporter)
  {
    let result = new("tt_HastyQuestionAnswerMatcher");

    result._knownTargetSource = knownTargetSource;
    result._answerSource      = answerSource;
    result._playerSource      = playerSource;
    result._reporter          = reporter;

    return result;
  }

  override tt_Origin getOrigin()
  {
    let targets = _knownTargetSource.getTargets();
    if (targets == NULL || targets.size() == 0) { return NULL; }

    let answer = _answerSource.getAnswer();
    if (answer == NULL) { return NULL; }

    let pawn   = _playerSource.getPawn();
    let result = findMatchedTarget(targets, answer, pawn);

    if (result != NULL)
    {
      _reporter.reportMatch();
      _answerSource.reset();
    }

    return result;
  }

  private tt_Origin findMatchedTarget(tt_KnownTargets targets,
                                      tt_Answer answer,
                                      Actor pawn)
  {
    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      let target   = targets.at(i);
      let question = target.getQuestion();

      if (!question.isRight(answer) || !isVisible(target, pawn))
      {
        continue;
      }

      let result = target.getTarget().getPosition();
      return result;
    }

    return NULL;
  }

  // Play-const hack: Actor.isVisible(...) is not const, but should be.
  private play bool isVisible(tt_KnownTarget target, Actor pawn) const
  {
    let  targetActor = target.getTarget().getActor();
    bool visible     = pawn.IsVisible(targetActor, ALL_AROUND);

    return visible;
  }

  const ALL_AROUND = 1; // true

  private tt_KnownTargetSource _knownTargetSource;
  private tt_AnswerSource      _answerSource;
  private tt_PlayerSource      _playerSource;
  private tt_AnswerReporter    _reporter;
}
#+end_src

** ~Origin~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/origin.zs

// Represents a point in space.
// Note that the Origin position cannot change once set.
class tt_Origin
{
  static tt_Origin of(Vector3 pos)
  {
    let result = new("tt_Origin");
    result._pos = pos;
    return result;
  }

  Vector3 getVector() const
  {
    return _pos;
  }

  private Vector3 _pos;
}
#+end_src

** ~OriginSource~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/origin_source.zs

// This interface represents a source of origins.
class tt_OriginSource abstract
{
  // Returns the origin (coordinate in 3D space).
  // Getting the origin doesn't change it.
  abstract tt_Origin getOrigin();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_OriginSourceMock : tt_OriginSource
{
  static tt_OriginSourceMock of() { return new("tt_OriginSourceMock"); }

  override tt_Origin getOrigin()
  {
    ++_mock_getOrigin_called;
    return _mock_getOrigin;
  }

  void expect_getOrigin(tt_Origin value, int expected = 1)
  {
    _mock_getOrigin = value;
    _mock_getOrigin_expected = expected;
    _mock_getOrigin_called = 0;
  }

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getOrigin",
            _mock_getOrigin_expected == _mock_getOrigin_called);
  }

  private tt_Origin _mock_getOrigin;
  private int _mock_getOrigin_expected;
  private int _mock_getOrigin_called;
}
#+end_src

** ~OriginSourceCache~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/origin_source_cache.zs

// Implements OriginSource by reading other OriginSource only if origin is stale.
class tt_OriginSourceCache : tt_OriginSource
{
  static tt_OriginSourceCache of(tt_OriginSource originSource,
                                 tt_StaleMarker staleMarker)
  {
    let result = new("tt_OriginSourceCache");

    result._originSource = originSource;
    result._staleMarker  = staleMarker;

    result._origin = NULL;

    return result;
  }

  override tt_Origin getOrigin()
  {
    if (_staleMarker.isStale())
    {
      _origin = _originSource.getOrigin();
    }

    return _origin;
  }

  private tt_OriginSource _originSource;
  private tt_StaleMarker  _staleMarker;

  private tt_Origin _origin;
}
#+end_src

** ~PlayerOriginSource~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/player_origin_source.zs

// Implements tt_OriginSource by providing the center of the player pawn.
class tt_PlayerOriginSource : tt_OriginSource
{
  static tt_PlayerOriginSource of(tt_PlayerSource playerSource)
  {
    let result = new("tt_PlayerOriginSource");

    result._playerSource = playerSource;

    return result;
  }

  override tt_Origin getOrigin()
  {
    let pawn = _playerSource.getPawn();
    let pos  = pawn.pos;
    pos.z += pawn.height / 2;

    return tt_Origin.of(pos);
  }

  private tt_PlayerSource _playerSource;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_PlayerOriginSource";

  double x = 1;
  double y = 2;
  double z = 3;
  let player = PlayerPawn(spawn("DoomPlayer", (x, y, z)));

  let playerSource = tt_PlayerSourceMock.of();
  let originSource = tt_PlayerOriginSource.of(playerSource);

  playerSource.expect_getPawn(player);

  let origin  = originSource.getOrigin().getVector();

  it(tag .. ": X matches",  AssertEval(x, "==", origin.x));
  it(tag .. ": Y matches",  AssertEval(y, "==", origin.y));
  it(tag .. ": Z in range", AssertEval(z, "<=", origin.z));
  it(tag .. ": Z in range", AssertEval(z + player.Height, ">=", origin.z));
  assertSatisfaction(playerSource.getSatisfaction(), tag);

  cleanUpSpawned();
}
#+end_src

** ~QuestionAnswerMatcher~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/question_answer_matcher.zs

// Implements OriginSource by finding an origin for a known target that fits to
// for the answer. Searches far matching target only if answer state is Ready.
class tt_QuestionAnswerMatcher : tt_OriginSource
{
  static tt_QuestionAnswerMatcher of(tt_KnownTargetSource knownTargetSource,
                                     tt_AnswerSource      answerSource,
                                     tt_PlayerSource      playerSource,
                                     tt_AnswerStateSource answerStateSource)
  {
    let result = new("tt_QuestionAnswerMatcher");

    result._knownTargetSource = knownTargetSource;
    result._answerSource      = answerSource;
    result._playerSource      = playerSource;
    result._answerStateSource = answerStateSource;

    return result;
  }

  override tt_Origin getOrigin()
  {
    let targets = _knownTargetSource.getTargets();
    if (targets == NULL || targets.size() == 0) { return NULL; }

    let answer = _answerSource.getAnswer();
    if (answer == NULL) { return NULL; }

    let answerState = _answerStateSource.getAnswerState();
    if (!answerState.isReady()) { return NULL; }

    let pawn   = _playerSource.getPawn();
    let result = findMatchedTarget(targets, answer, pawn);

    return result;
  }

  private tt_Origin findMatchedTarget(tt_KnownTargets targets,
                                      tt_Answer answer, Actor pawn)
  {
    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      let target   = targets.at(i);
      let question = target.getQuestion();

      if (!question.isRight(answer) || !isVisible(target, pawn))
      {
        continue;
      }

      let result = target.getTarget().getPosition();
      return result;
    }

    return NULL;
  }

  // Play-const hack: Actor.isVisible(...) is not const, but should be.
  private play bool isVisible(tt_KnownTarget target, Actor pawn) const
  {
    let  targetActor = target.getTarget().getActor();
    bool visible     = pawn.IsVisible(targetActor, ALL_AROUND);

    return visible;
  }

  const ALL_AROUND = 1; // true

  private tt_KnownTargetSource _knownTargetSource;
  private tt_AnswerSource      _answerSource;
  private tt_PlayerSource      _playerSource;
  private tt_AnswerStateSource _answerStateSource;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_QuestionAnswerMatcher: checkNullKnownTargets";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  env.targetSource.expect_getTargets(NULL);

  let origin = env.matcher.getOrigin();

  it(tag .. ": NULL known targets -> NULL origin", AssertNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_QuestionAnswerMatcher: checkZeroKnownTargets";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  let targets = tt_KnownTargets.of();
  env.targetSource.expect_getTargets(targets);

  let origin = env.matcher.getOrigin();

  it(tag .. "Zero known targets -> NULL origin", AssertNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_QuestionAnswerMatcher: checkNullKnownTarget";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  let targets = tt_KnownTargets.of();
  targets.add(NULL);
  env.targetSource.expect_getTargets(targets);
  env.answerSource.expect_getAnswer(NULL);

  let origin = env.matcher.getOrigin();

  it(tag .. ": NULL known target -> NULL origin", AssertNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_QuestionAnswerMatcher: checkNullAnswer";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  let knownTargets = tt_KnownTargets.of();
  let target       = tt_Target.of(NULL);
  let question     = tt_QuestionMock.of();
  let knownTarget  = tt_KnownTarget.of(target, question);
  knownTargets.add(knownTarget);
  env.targetSource.expect_getTargets(knownTargets);
  env.answerSource.expect_getAnswer(NULL);

  let origin = env.matcher.getOrigin();

  it(tag .. ": NULL answer -> NULL origin", AssertNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_QuestionAnswerMatcher: checkKnownTargetAndAnswerMatch";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  let knownTargets = tt_KnownTargets.of();
  let target       = tt_Target.of(spawn("Demon", (0, 0, 0)));
  let question     = tt_QuestionMock.of();
  let knownTarget  = tt_KnownTarget.of(target, question);
  knownTargets.add(knownTarget);
  env.targetSource.expect_getTargets(knownTargets);
  question.expect_isRight(true);

  let answer = tt_Answer.of("abc");
  env.answerSource.expect_getAnswer(answer);
  env.stateSource.expect_getAnswerState(tt_AnswerState.of(tt_AnswerState.Ready));
  env.playerSource.expect_getPawn(players[consolePlayer].mo);

  let origin = env.matcher.getOrigin();

  assertSatisfaction(question.getSatisfaction(), tag);
  it(tag .. ": match: valid origin", AssertNotNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_QuestionAnswerMatcher: checkKnownTargetAndAnswerNoMatch";
  let env = tt_QuestionAnswerMatcherTestEnvironment.of();

  let knownTargets = tt_KnownTargets.of();
  let target       = tt_Target.of(NULL);
  let question     = tt_QuestionMock.of();
  let knownTarget  = tt_KnownTarget.of(target, question);
  knownTargets.add(knownTarget);
  env.targetSource.expect_getTargets(knownTargets);
  question.expect_isRight(false);

  let answer = tt_Answer.of("abc");
  env.answerSource.expect_getAnswer(answer);
  env.stateSource.expect_getAnswerState(tt_AnswerState.of(tt_AnswerState.Ready));
  env.playerSource.expect_getPawn(players[consolePlayer].mo);

  let origin = env.matcher.getOrigin();

  assertSatisfaction(question.getSatisfaction(), tag);
  it(tag .. ": no match: NULL origin" , AssertNull(origin));

  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_QuestionAnswerMatcherTestEnvironment
{
  static tt_QuestionAnswerMatcherTestEnvironment of()
  {
    let result = new("tt_QuestionAnswerMatcherTestEnvironment");
    result.targetSource = tt_KnownTargetSourceMock.of();
    result.answerSource = tt_AnswerSourceMock.of();
    result.playerSource = tt_PlayerSourceMock.of();
    result.stateSource  = tt_AnswerStateSourceMock.of();

    result.matcher = tt_QuestionAnswerMatcher.of(result.targetSource,
                                                 result.answerSource,
                                                 result.playerSource,
                                                 result.stateSource);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return targetSource.getSatisfaction()
      .add(answerSource.getSatisfaction())
      .add(playerSource.getSatisfaction())
      .add(stateSource.getSatisfaction());
  }

  tt_KnownTargetSourceMock targetSource;
  tt_AnswerSourceMock      answerSource;
  tt_PlayerSourceMock      playerSource;
  tt_AnswerStateSourceMock stateSource;
  tt_QuestionAnswerMatcher matcher;
}
#+end_src

** ~SelectableOriginSource~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/selectable_origin_source.zs

// Implements OriginSource by selecting one of the two supplied
// origin sources based on a certain value from tt_Settings.
class tt_SelectableOriginSource : tt_OriginSource
{
  static tt_SelectableOriginSource of(tt_OriginSource source1,
                                      tt_OriginSource source2,
                                      tt_Settings     settings)
  {
    let result = new("tt_SelectableOriginSource");

    result._source1 = source1;
    result._source2 = source2;
    result._settings = settings;

    return result;
  }

  override tt_Origin getOrigin()
  {
    return _settings.isFastConfirmation()
      ? _source1.getOrigin()
      : _source2.getOrigin() ;
  }

  private tt_OriginSource _source1;
  private tt_OriginSource _source2;
  private tt_Settings     _settings;
}
#+end_src

** ~ExternalOriginSource~

#+begin_src c :tangle build/Typist.pk3/zscript/origin/origin_source_cache.zs

// Implements tt_OriginSource by receiving the source from elsewhere.
class tt_ExternalOriginSource : tt_OriginSource
{
  static tt_ExternalOriginSource of()
  {
    let result = new("tt_ExternalOriginSource");
    return result;
  }

  override tt_Origin getOrigin()
  {
    return _origin;
  }

  void setOrigin(tt_Origin origin)
  {
    _origin = origin;
  }

  private tt_Origin _origin;
}
#+end_src

* Player

** ~PlayerSource~

#+begin_src c :tangle build/Typist.pk3/zscript/player/player_source.zs

// Interface for getting player info and player pawn.
class tt_PlayerSource abstract
{
  abstract PlayerInfo getInfo();

  abstract PlayerPawn getPawn();

  abstract int getNumber();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_PlayerSourceMock : tt_PlayerSource
{
  static tt_PlayerSourceMock of() { return new("tt_PlayerSourceMock"); }

  override PlayerInfo getInfo()
  {
    ++_mock_getInfo_called;
    return _mock_getInfo;
  }

  void expect_getInfo(PlayerInfo value, int expected = 1)
  {
    _mock_getInfo = value;
    _mock_getInfo_expected = expected;
    _mock_getInfo_called = 0;
  }

  private PlayerInfo _mock_getInfo;
  private int _mock_getInfo_expected;
  private int _mock_getInfo_called;

  override PlayerPawn getPawn()
  {
    ++_mock_getPawn_called;
    return _mock_getPawn;
  }

  void expect_getPawn(PlayerPawn value, int expected = 1)
  {
    _mock_getPawn = value;
    _mock_getPawn_expected = expected;
    _mock_getPawn_called = 0;
  }

  override int getNumber()
  {
    throwAbortException("implement this!");
    return 0;
  }

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getInfo",
            _mock_getInfo_expected == _mock_getInfo_called)
      .push(getClassName() .. ": getPawn",
            _mock_getPawn_expected == _mock_getPawn_called);
  }

  private PlayerPawn _mock_getPawn;
  private int _mock_getPawn_expected;
  private int _mock_getPawn_called;
}
#+end_src

*** ~PlayerSourceImpl~

#+begin_src c :tangle build/Typist.pk3/zscript/player/player_source_impl.zs

// Implements tt_PlayerSource by returning player by player number.
class tt_PlayerSourceImpl : tt_PlayerSource
{
  static tt_PlayerSourceImpl of(int playerNumber)
  {
    let result           = new ("tt_PlayerSourceImpl");
    result._playerNumber = playerNumber;
    return result;
  }

  override PlayerInfo getInfo() { return players[_playerNumber]; }

  override PlayerPawn getPawn() { return getInfo().mo; }

  override int getNumber() { return _playerNumber; }

  private int _playerNumber;
}
#+end_src

**** Test

#+begin_src c :noweb-ref test-body
{
  // Info, unlike pawns, exist even for non-existent players.
  for (int playerNumber = 0; playerNumber < MAXPLAYERS; ++playerNumber)
  {
    let source = tt_PlayerSourceImpl.of(playerNumber);
    let info   = source.getInfo();
    let note   = "tt_PlayerSourceImpl: player info (%d) must be not NULL";

    it(string.format(note, playerNumber), Assert(info != NULL));
  }
}
{
  let source = tt_PlayerSourceImpl.of(consolePlayer);
  let pawn   = source.getPawn();
  let note   = "tt_PlayerSourceImpl: must get main player (%d) actor";

  it(string.format(note, consolePlayer), AssertNotNull(pawn));
}
{
  let note = "tt_PlayerSourceImpl: other player (%d) must be null";

  // Since tests are run on single-player game, no other players must exist.
  for (int i = 1; i < MAXPLAYERS; ++i)
  {
    int playerNumber = (consolePlayer + i) % MAXPLAYERS;
    let source       = tt_PlayerSourceImpl.of(playerNumber);
    let pawn         = source.getPawn();

    it(string.format(note, playerNumber), AssertNull(pawn));
  }
}
#+end_src

* Question

** ~Match~

#+begin_src c :tangle build/Typist.pk3/zscript/question/match.zs

// Implements tt_Question. The answer is right for this kind of question if it
// matches the string contained in this question.
class tt_Match : tt_Question
{
  static tt_Match of(String question, string description)
  {
    let result = new("tt_Match");

    result._question    = question;
    result._description = description;

    return result;
  }

  override bool isRight(tt_Answer answer)
  {
    bool isEqual = (_question == answer.getString());
    return isEqual;
  }

  override string getDescription()
  {
    return _description;
  }

  override string getHintFor(tt_Answer answer)
  {
    return getColoredMatch(_question, answer.getString());
  }

  private string getColoredMatch(String origin, string matched)
  {
    string result;

    int originLength   = origin .CodePointCount();
    int matchedLength  = matched.CodePointCount();
    int nChars         = min(originLength, matchedLength);
    int originCharPos  = 0;
    int matchedCharPos = 0;

    for (int i = 0; i < nChars; ++i)
    {
      int nextOriginCharPos;
      int nextMatchedCharPos;
      int originCode;
      int matchedCode;
      [originCode,  nextOriginCharPos ] = origin .GetNextCodePoint(originCharPos );
      [matchedCode, nextMatchedCharPos] = matched.GetNextCodePoint(matchedCharPos);

      bool   isCharSame = (originCode == matchedCode);
      string colorCode  = (isCharSame ? "j" : "g"); // white, red

      result.appendFormat("\c%s%c", colorCode, matchedCode);

      originCharPos  = nextOriginCharPos;
      matchedCharPos = nextMatchedCharPos;
    }

    if (matchedLength > originLength)
    {
      // everything that is beyond origin is wrong.
      result.appendFormat("\cg%s", matched.Mid(matchedCharPos));
    }

    return result;
  }

  private string _question;
  private string _description;
}
#+end_src

** ~Question~

#+begin_src c :tangle build/Typist.pk3/zscript/question/question.zs

// This interface represents a question.
class tt_Question abstract
{
  abstract bool isRight(tt_Answer answer);

  abstract string getDescription();

  abstract string getHintFor(tt_Answer answer);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_QuestionMock : tt_Question
{
  static tt_QuestionMock of() { return new("tt_QuestionMock"); }

  override bool isRight(tt_Answer answer)
  {
    ++_mock_isRight_called;
    return _mock_isRight;
  }

  void expect_isRight(bool value, int expected = 1)
  {
    _mock_isRight = value;
    _mock_isRight_expected = expected;
    _mock_isRight_called = 0;
  }

  private bool _mock_isRight;
  private int _mock_isRight_expected;
  private int _mock_isRight_called;

  override string getDescription()
  {
    ++_mock_getDescription_called;
    return _mock_getDescription;
  }

  void expect_getDescription(String value, int expected = 1)
  {
    _mock_getDescription = value;
    _mock_getDescription_expected = expected;
    _mock_getDescription_called = 0;
  }

  private string _mock_getDescription;
  private int _mock_getDescription_expected;
  private int _mock_getDescription_called;

  override string getHintFor(tt_Answer answer)
  {
    ++_mock_getHintFor_called;
    return _mock_getHintFor;
  }

  void expect_getHintFor(String value, int expected = 1)
  {
    _mock_getHintFor = value;
    _mock_getHintFor_expected = expected;
    _mock_getHintFor_called = 0;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. "isRight",
            _mock_isRight_expected == _mock_isRight_called)
      .push(getClassName() .. "getDescription",
            _mock_getDescription_expected == _mock_getDescription_called)
      .push(getClassName() .. "getHintFor",
            _mock_getHintFor_expected == _mock_getHintFor_called);
  }

  private string _mock_getHintFor;
  private int _mock_getHintFor_expected;
  private int _mock_getHintFor_called;
}
#+end_src

* Settings

** ~Cvar~

#+begin_src c :tangle build/Typist.pk3/zscript/settings/cvar.zs

// Provides access to a user or server Cvar. Accessing Cvars through this class
// is faster because calling Cvar.getCvar() is costly. Caches the result of
// Cvar.getCvar() and handles loading a savegame.
class tt_Cvar
{
  static tt_Cvar of(tt_PlayerSource playerSource, string name)
  {
    let result = new("tt_Cvar");

    result._playerSource = playerSource;
    result._name         = name;

    return result;
  }

  bool   isDefined() { load(); return (_cvar != NULL);   }

  string getString() { load(); return _cvar.getString(); }
  bool   getBool()   { load(); return _cvar.getInt();    }
  int    getInt()    { load(); return _cvar.getInt();    }
  double getFloat()  { load(); return _cvar.getFloat();  }

  private void load()
  {
    if (_cvar == NULL)
    {
      let playerInfo = _playerSource.getInfo();

      _cvar = Cvar.getCvar(_name, playerInfo);

      if (_cvar == NULL)
      {
        Console.printf("Cvar %s not found.", _name);
      }
    }
  }

  private tt_PlayerSource _playerSource;
  private string          _name;
  private transient Cvar  _cvar;
}
#+end_src

** ~CommandSettings~

#+begin_src c :tangle build/Typist.pk3/zscript/settings/command_settings.zs

// This interface provides access to Typist.pk3 Commands settings.
class tt_CommandSettings abstract
{
  abstract string getPassThroughCommand();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_CommandSettingsMock : tt_CommandSettings
{
  static tt_CommandSettingsMock of() { return new("tt_CommandSettingsMock"); }

  override string getPassThroughCommand()
  {
    throwAbortException("implement this!");
    return "";
  }

  tt_Satisfaction getSatisfaction() const
  {
    return tt_Satisfaction.of();
  }
}
#+end_src

*** ~CommandSettingsImpl~

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// Command settings

user string tt_command_pass_through = "/pass";
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/settings/command_settings_impl.zs

// Implements tt_CommandSettings interface by reading the Cvars.
class tt_CommandSettingsImpl : tt_CommandSettings
{
  static tt_CommandSettingsImpl of(tt_PlayerSource playerSource)
  {
    let result = new("tt_CommandSettingsImpl");
    result._commandPassThroughCvar = tt_Cvar.of(playerSource,
                                                "tt_command_pass_through");
    return result;
  }

  override string getPassThroughCommand()
  {
    return _commandPassThroughCvar.getString();
  }

  private tt_Cvar _commandPassThroughCvar;
}
#+end_src

** ~RandomCharactersLessonSettings~

#+begin_src c :tangle build/Typist.pk3/zscript/settings/random_characters_lesson_settings.zs

// Represents settings for tt_RandomCharactersLesson.
class tt_RandomCharactersLessonSettings abstract
{
  abstract int getLessonLength();

  abstract bool isUppercaseLettersEnabled();

  abstract bool isLowercaseLettersEnabled();

  abstract bool isNumbersEnabled();

  abstract bool isPunctuationEnabled();

  abstract bool isSymbolsEnabled();

  abstract bool isCustomCharactersEnabled();

  abstract string getCustomCharacters();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_RandomCharactersLessonSettingsMock : tt_RandomCharactersLessonSettings
{
  static tt_RandomCharactersLessonSettingsMock of() { return new("tt_RandomCharactersLessonSettingsMock"); }

  override int getLessonLength()
  {
    ++_mock_getLessonLength_called;
    return _mock_getLessonLength;
  }

  void expect_getLessonLength(int value, int expected = 1)
  {
    _mock_getLessonLength = value;
    _mock_getLessonLength_expected = expected;
    _mock_getLessonLength_called = 0;
  }

  private int _mock_getLessonLength;
  private int _mock_getLessonLength_expected;
  private int _mock_getLessonLength_called;

  override bool isUppercaseLettersEnabled()
  {
    ++_mock_isUppercaseLettersEnabled_called;
    return _mock_isUppercaseLettersEnabled;
  }

  void expect_isUppercaseLettersEnabled(bool value, int expected = 1)
  {
    _mock_isUppercaseLettersEnabled = value;
    _mock_isUppercaseLettersEnabled_expected = expected;
    _mock_isUppercaseLettersEnabled_called = 0;
  }

  private bool _mock_isUppercaseLettersEnabled;
  private int _mock_isUppercaseLettersEnabled_expected;
  private int _mock_isUppercaseLettersEnabled_called;

  override bool isLowercaseLettersEnabled()
  {
    ++_mock_isLowercaseLettersEnabled_called;
    return _mock_isLowercaseLettersEnabled;
  }

  void expect_isLowercaseLettersEnabled(bool value, int expected = 1)
  {
    _mock_isLowercaseLettersEnabled = value;
    _mock_isLowercaseLettersEnabled_expected = expected;
    _mock_isLowercaseLettersEnabled_called = 0;
  }

  private bool _mock_isLowercaseLettersEnabled;
  private int _mock_isLowercaseLettersEnabled_expected;
  private int _mock_isLowercaseLettersEnabled_called;

  override bool isNumbersEnabled()
  {
    ++_mock_isNumbersEnabled_called;
    return _mock_isNumbersEnabled;
  }

  void expect_isNumbersEnabled(bool value, int expected = 1)
  {
    _mock_isNumbersEnabled = value;
    _mock_isNumbersEnabled_expected = expected;
    _mock_isNumbersEnabled_called = 0;
  }

  private bool _mock_isNumbersEnabled;
  private int _mock_isNumbersEnabled_expected;
  private int _mock_isNumbersEnabled_called;

  override bool isPunctuationEnabled()
  {
    ++_mock_isPunctuationEnabled_called;
    return _mock_isPunctuationEnabled;
  }

  void expect_isPunctuationEnabled(bool value, int expected = 1)
  {
    _mock_isPunctuationEnabled = value;
    _mock_isPunctuationEnabled_expected = expected;
    _mock_isPunctuationEnabled_called = 0;
  }

  private bool _mock_isPunctuationEnabled;
  private int _mock_isPunctuationEnabled_expected;
  private int _mock_isPunctuationEnabled_called;

  override bool isSymbolsEnabled()
  {
    ++_mock_isSymbolsEnabled_called;
    return _mock_isSymbolsEnabled;
  }

  void expect_isSymbolsEnabled(bool value, int expected = 1)
  {
    _mock_isSymbolsEnabled = value;
    _mock_isSymbolsEnabled_expected = expected;
    _mock_isSymbolsEnabled_called = 0;
  }

  private bool _mock_isSymbolsEnabled;
  private int _mock_isSymbolsEnabled_expected;
  private int _mock_isSymbolsEnabled_called;

  override bool isCustomCharactersEnabled()
  {
    ++_mock_isCustomCharactersEnabled_called;
    return _mock_isCustomCharactersEnabled;
  }

  void expect_isCustomCharactersEnabled(bool value, int expected = 1)
  {
    _mock_isCustomCharactersEnabled = value;
    _mock_isCustomCharactersEnabled_expected = expected;
    _mock_isCustomCharactersEnabled_called = 0;
  }

  private bool _mock_isCustomCharactersEnabled;
  private int _mock_isCustomCharactersEnabled_expected;
  private int _mock_isCustomCharactersEnabled_called;

  override string getCustomCharacters()
  {
    ++_mock_getCustomCharacters_called;
    return _mock_getCustomCharacters;
  }

  void expect_getCustomCharacters(String value, int expected = 1)
  {
    _mock_getCustomCharacters = value;
    _mock_getCustomCharacters_expected = expected;
    _mock_getCustomCharacters_called = 0;
  }

  private string _mock_getCustomCharacters;
  private int _mock_getCustomCharacters_expected;
  private int _mock_getCustomCharacters_called;
}
#+end_src

*** ~RandomCharactersLessonSettingsImpl~

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// Random Character Lesson configuration ///////////////////////////////////////

server int    tt_rc_length = 3;

server bool   tt_rc_uppercase_letters_enabled = false;
server bool   tt_rc_lowercase_letters_enabled = true;
server bool   tt_rc_numbers_enabled           = false;
server bool   tt_rc_punctuation_enabled       = false;
server bool   tt_rc_symbols_enabled           = false;

server bool   tt_rc_custom_enabled = false;
server string tt_rc_custom         = "";
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/settings/random_characters_lesson_settings_impl.zs

// Implements tt_RandomCharactersLessonSettings by returning Cvar contents.
// Cvars are cached.
class tt_RandomCharactersLessonSettingsImpl : tt_RandomCharactersLessonSettings
{
  static tt_RandomCharactersLessonSettingsImpl of(tt_PlayerSource playerSource)
  {
    let result = new("tt_RandomCharactersLessonSettingsImpl");

    result._lessonLength         = tt_Cvar.of(playerSource, "tt_rc_length");
    result._isUppercaseEnabled   = tt_Cvar.of(playerSource, "tt_rc_uppercase_letters_enabled");
    result._isLowercaseEnabled   = tt_Cvar.of(playerSource, "tt_rc_lowercase_letters_enabled");
    result._isNumbersEnabled     = tt_Cvar.of(playerSource, "tt_rc_numbers_enabled");
    result._isPunctuationEnabled = tt_Cvar.of(playerSource, "tt_rc_punctuation_enabled");
    result._isSymbolsEnabled     = tt_Cvar.of(playerSource, "tt_rc_symbols_enabled");
    result._isCustomEnabled      = tt_Cvar.of(playerSource, "tt_rc_custom_enabled");
    result._customCharacters     = tt_Cvar.of(playerSource, "tt_rc_custom");

    return result;
  }

  override int    getLessonLength()           { return _lessonLength.getInt();          }
  override bool   isUppercaseLettersEnabled() { return _isUppercaseEnabled.getBool();   }
  override bool   isLowercaseLettersEnabled() { return _isLowercaseEnabled.getBool();   }
  override bool   isNumbersEnabled()          { return _isNumbersEnabled.getBool();     }
  override bool   isPunctuationEnabled()      { return _isPunctuationEnabled.getBool(); }
  override bool   isSymbolsEnabled()          { return _isSymbolsEnabled.getBool();     }
  override bool   isCustomCharactersEnabled() { return _isCustomEnabled.getBool();      }
  override string getCustomCharacters()       { return _customCharacters.getString();   }

  private tt_Cvar _lessonLength;
  private tt_Cvar _isUppercaseEnabled;
  private tt_Cvar _isLowercaseEnabled;
  private tt_Cvar _isNumbersEnabled;
  private tt_Cvar _isPunctuationEnabled;
  private tt_Cvar _isSymbolsEnabled;
  private tt_Cvar _isCustomEnabled;
  private tt_Cvar _customCharacters;
}
#+end_src

** ~Settings~

#+begin_src c :tangle build/Typist.pk3/zscript/settings/settings.zs

// This interface provides access to Typist.pk3 settings.
class tt_Settings abstract
{
  abstract int getScale();

  abstract bool isAutoAimEnabled();

  abstract int getLessonIndex();

  abstract bool getLessonEnabled(uint i);

  abstract bool isFastConfirmation();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_SettingsMock : tt_Settings
{
  static tt_SettingsMock of() { return new("tt_SettingsMock"); }

  override int getScale()
  {
    ++_mock_getScale_called;
    return _mock_getScale;
  }

  void expect_getScale(int value, int expected = 1)
  {
    _mock_getScale = value;
    _mock_getScale_expected = expected;
    _mock_getScale_called = 0;
  }

  private int _mock_getScale;
  private int _mock_getScale_expected;
  private int _mock_getScale_called;

  override bool isAutoAimEnabled()
  {
    ++_mock_isAutoAimEnabled_called;
    return _mock_isAutoAimEnabled;
  }

  void expect_isAutoAimEnabled(bool value, int expected = 1)
  {
    _mock_isAutoAimEnabled = value;
    _mock_isAutoAimEnabled_expected = expected;
    _mock_isAutoAimEnabled_called = 0;
  }

  private bool _mock_isAutoAimEnabled;
  private int _mock_isAutoAimEnabled_expected;
  private int _mock_isAutoAimEnabled_called;

  override int getLessonIndex()
  {
    ++_mock_getLessonIndex_called;
    return _mock_getLessonIndex;
  }

  void expect_getLessonIndex(int value, int expected = 1)
  {
    _mock_getLessonIndex = value;
    _mock_getLessonIndex_expected = expected;
    _mock_getLessonIndex_called = 0;
  }

  private int _mock_getLessonIndex;
  private int _mock_getLessonIndex_expected;
  private int _mock_getLessonIndex_called;

  override bool getLessonEnabled(uint i)
  {
    ++_mock_getLessonEnabled_called;
    return _mock_getLessonEnabled;
  }

  void expect_getLessonEnabled(bool value, int expected = 1)
  {
    _mock_getLessonEnabled = value;
    _mock_getLessonEnabled_expected = expected;
    _mock_getLessonEnabled_called = 0;
  }

  private bool _mock_getLessonEnabled;
  private int _mock_getLessonEnabled_expected;
  private int _mock_getLessonEnabled_called;

  override bool isFastConfirmation()
  {
    ++_mock_isFastConfirmation_called;
    return _mock_isFastConfirmation;
  }

  void expect_isFastConfirmation(bool value, int expected = 1)
  {
    _mock_isFastConfirmation = value;
    _mock_isFastConfirmation_expected = expected;
    _mock_isFastConfirmation_called = 0;
  }

  private bool _mock_isFastConfirmation;
  private int _mock_isFastConfirmation_expected;
  private int _mock_isFastConfirmation_called;

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": isFastConfirmation",
            _mock_isFastConfirmation_expected == _mock_isFastConfirmation_called)
      .push(getClassName() .. ": getLessonEnabled",
            _mock_getLessonEnabled_expected == _mock_getLessonEnabled_called)
      .push(getClassName() .. "getLessonIndex",
            _mock_getLessonIndex_expected ==
            _mock_getLessonIndex_called)
      .push(getClassName() .. ": isAutoAimEnabled",
            _mock_isAutoAimEnabled_expected == _mock_isAutoAimEnabled_called)
      .push(getClassName() .. ": getScale",
            _mock_getScale_expected == _mock_getScale_called);
  }
}
#+end_src

*** ~SettingsImpl~

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// General settings

user int tt_view_scale = 1;

// Attention! Do not set values which are not in the list in menudef.txt.
user int tt_question_source = 4;

// 0: by Enter or Space
// 1: Automatic, as soon as an answer matches.
user int tt_confirm_type = 0;

// Mixed Lesson configuration //////////////////////////////////////////////////

server bool tt_is_lesson_enabled_0 = false;
server bool tt_is_lesson_enabled_1 = false;
server bool tt_is_lesson_enabled_2 = false;
server bool tt_is_lesson_enabled_3 = false;
server bool tt_is_lesson_enabled_4 = false;
server bool tt_is_lesson_enabled_5 = false;
server bool tt_is_lesson_enabled_6 = false;
server bool tt_is_lesson_enabled_7 = false;
server bool tt_is_lesson_enabled_8 = false;
server bool tt_is_lesson_enabled_9 = false;
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/settings/settings_impl.zs

// Implements tt_Settings by reading values from user CVars.
class tt_SettingsImpl : tt_Settings

{
  static tt_SettingsImpl of(tt_PlayerSource playerSource)
  {
    let result = new ("tt_SettingsImpl");

    result._scaleCvar              = tt_Cvar.of(playerSource, "tt_view_scale");
    result._autoaimCvar            = tt_Cvar.of(playerSource, "autoaim");
    result._lessonIndexCvar        = tt_Cvar.of(playerSource, "tt_question_source");
    result._isFastConfirmationCvar = tt_Cvar.of(playerSource, "tt_confirm_type");

    for (uint i = 0; i < N_IS_LESSON_ENABLED_CVARS; ++i)
    {
      string cvarName = string.format("tt_is_lesson_enabled_%d", i);
      result._isLessonEnabledCvars.push(tt_Cvar.of(playerSource, cvarName));
    }

    return result;
  }

  override int getScale() { return max(1, _scaleCvar.getInt()); }

  override bool isAutoAimEnabled() { return (_autoaimCvar.getFloat() > 34.5); }

  override int getLessonIndex() { return _lessonIndexCvar.getInt(); }

  override bool isFastConfirmation() { return _isFastConfirmationCvar.getInt(); }

  override bool getLessonEnabled(uint index)
  {
    return _isLessonEnabledCvars[index].getBool();
  }

  const N_IS_LESSON_ENABLED_CVARS = 10;

  private tt_Cvar _scaleCvar;
  private tt_Cvar _autoaimCvar;
  private tt_Cvar _lessonIndexCvar;
  private tt_Cvar _isFastConfirmationCvar;

  private Array<tt_Cvar> _isLessonEnabledCvars;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_SettingsImpl: testGetScale";
  let playerSource = tt_PlayerSourceMock.of();
  let settings     = tt_SettingsImpl.of(playerSource);

  playerSource.expect_getInfo(players[consolePlayer]);

  int scale = settings.getScale();
  // second call to getScale must not get player info again.
  scale = settings.getScale();

  assertSatisfaction(playerSource.getSatisfaction(), tag);
  it(tag .. ": scale is more than zero", AssertEval(scale, ">", 0));
}
{
  let tag = "tt_SettingsImpl: testIsAutoaimEnabled";
  let playerSource = tt_PlayerSourceMock.of();
  let settings     = tt_SettingsImpl.of(playerSource);

  playerSource.expect_getInfo(players[consolePlayer]);

  bool isAutoaimEnabled = settings.isAutoaimEnabled();
  // second call must not get player info again.
  isAutoaimEnabled = settings.isAutoaimEnabled();

  assertSatisfaction(playerSource.getSatisfaction(), tag);
}
{
  let tag = "tt_SettingsImpl: testGetLesson";
  let playerSource = tt_PlayerSourceMock.of();
  let settings     = tt_SettingsImpl.of(playerSource);

  playerSource.expect_getInfo(players[consolePlayer]);

  int lessonIndex = settings.getLessonIndex();

  it(tag .. ": question source index is reasonable",
     AssertEval(lessonIndex, ">=", 0));
  assertSatisfaction(playerSource.getSatisfaction(), tag);
}
#+end_src

** ~SoundSettings~

#+begin_src c :tangle build/Typist.pk3/zscript/settings/sound_settings.zs

// Provides access to Typist.pk3 sound settings.
class tt_SoundSettings abstract
{
  abstract bool isEnabled();

  abstract bool isTypingEnabled();

  abstract int getTheme();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_SoundSettingsMock : tt_SoundSettings
{
  static tt_SoundSettingsMock of() { return new("tt_SoundSettingsMock"); }

  override bool isEnabled()
  {
    ++_mock_isEnabled_called;
    return _mock_isEnabled;
  }

  void expect_isEnabled(bool value, int expected = 1)
  {
    _mock_isEnabled = value;
    _mock_isEnabled_expected = expected;
    _mock_isEnabled_called = 0;
  }

  private bool _mock_isEnabled;
  private int _mock_isEnabled_expected;
  private int _mock_isEnabled_called;

  override bool isTypingEnabled()
  {
    ++_mock_isTypingEnabled_called;
    return _mock_isTypingEnabled;
  }

  void expect_isTypingEnabled(bool value, int expected = 1)
  {
    _mock_isTypingEnabled = value;
    _mock_isTypingEnabled_expected = expected;
    _mock_isTypingEnabled_called = 0;
  }

  private bool _mock_isTypingEnabled;
  private int _mock_isTypingEnabled_expected;
  private int _mock_isTypingEnabled_called;

  override int getTheme()
  {
    ++_mock_getTheme_called;
    return _mock_getTheme;
  }

  void expect_getTheme(int value, int expected = 1)
  {
    _mock_getTheme = value;
    _mock_getTheme_expected = expected;
    _mock_getTheme_called = 0;
  }

  private int _mock_getTheme;
  private int _mock_getTheme_expected;
  private int _mock_getTheme_called;
}
#+end_src

*** ~SoundSettingsImpl~

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// Sound settings //////////////////////////////////////////////////////////////

user bool tt_sound_enabled = true;
user int  tt_sound_theme = 1;
user bool tt_sound_typing_enabled = true;
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/settings/sound_settings_impl.zs

// Implements tt_SoundSettings by reading CVars.
class tt_SoundSettingsImpl : tt_SoundSettings
{
  static tt_SoundSettingsImpl of(tt_PlayerSource playerSource)
  {
    let result = new("tt_SoundSettingsImpl");

    result._enabledCvar       = tt_Cvar.of(playerSource, "tt_sound_enabled"       );
    result._soundThemeCvar    = tt_Cvar.of(playerSource, "tt_sound_theme"         );
    result._typingEnabledCvar = tt_Cvar.of(playerSource, "tt_sound_typing_enabled");

    return result;
  }

  override bool isEnabled()       { return _enabledCvar       . getBool(); }
  override bool isTypingEnabled() { return _typingEnabledCvar . getBool(); }
  override int  getTheme()        { return _soundThemeCvar    . getInt (); }

  private tt_Cvar _soundThemeCvar;
  private tt_Cvar _enabledCvar;
  private tt_cvar _typingEnabledCvar;
}
#+end_src

* Stale Marker

** ~StaleMarker~

#+begin_src c :tangle build/Typist.pk3/zscript/stale_marker/stale_marker.zs

// This interface provides information when its instance becomes stale.
class tt_StaleMarker abstract
{
  // Update stale status.
  // Attention! Calling this function may change the state of tt_StaleMarker.
  // Returns true if this instance is currently stale.
  abstract bool isStale();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_StaleMarkerMock : tt_StaleMarker
{
  static tt_StaleMarkerMock of() { return new("tt_StaleMarkerMock"); }

  override bool isStale()
  {
    ++_mock_isStale_called;
    return _mock_isStale;
  }

  void expect_isStale(bool value, int expected = 1)
  {
    _mock_isStale = value;
    _mock_isStale_expected = expected;
    _mock_isStale_called = 0;
  }

  private bool _mock_isStale;
  private int _mock_isStale_expected;
  private int _mock_isStale_called;
}
#+end_src

** ~StaleMarkerImpl~

#+begin_src c :tangle build/Typist.pk3/zscript/stale_marker/stale_marker_impl.zs

// Implements tt_StaleMarker by observing a tt_Clock.
class tt_StaleMarkerImpl : tt_StaleMarker
{
  // Creates an instance of tt_StaleMarkerImpl.
  // clock: dependency, a clock to be observed.
  // updateTicks: in how much ticks this marker becomes stale.
  static tt_StaleMarkerImpl of(tt_Clock clock, int updateTicks = 1)
  {
    let result = new("tt_StaleMarkerImpl");

    result._clock       = clock;

    result._updateTicks = updateTicks;
    result._isEmpty     = true;
    result._oldMoment   = 0;

    return result;
  }

  override bool isStale()
  {
    if (!shouldUpdate()) return false;

    _oldMoment = _clock.getNow();
    _isEmpty   = false;

    return true;
  }

  private bool shouldUpdate() const
  {
    if (_isEmpty) return true;

    int  passed     = _clock.since(_oldMoment);
    bool isObsolete = (passed >= _updateTicks);

    return isObsolete;
  }

  private tt_Clock _clock;

  private int  _updateTicks;
  private bool _isEmpty;
  private int  _oldMoment;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_StaleMarker: checkFirstRead";
  let env = tt_StaleMarkerImplTestEnvironment.of();
  env.clock.expect_getNow(0);

  bool isStale = env.staleMarker.isStale();
  it(tag .. ": first read: stale", Assert(isStale));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_StaleMarker: checkNotYetStale";
  let env = tt_StaleMarkerImplTestEnvironment.of();
  env.clock.expect_getNow(0);

  bool isStale1 = env.staleMarker.isStale();

  env.clock.expect_since(0);
  bool isStale2 = env.staleMarker.isStale();
  it(tag .. ": same tick: not stale", Assert(!isStale2));
  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_StaleMarker: checkAlreadyStale";
  let env = tt_StaleMarkerImplTestEnvironment.of();
  env.clock.expect_getNow(0, 2);

  bool isStale1 = env.staleMarker.isStale();

  env.clock.expect_since(1);
  bool isStale2 = env.staleMarker.isStale();
  it(tag .. ": new tick: stale", Assert(isStale2));
  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_StaleMarkerImplTestEnvironment
{
  static tt_StaleMarkerImplTestEnvironment of()
  {
    let result = new("tt_StaleMarkerImplTestEnvironment");
    result.clock = tt_ClockMock.of();
    result.staleMarker = tt_StaleMarkerImpl.of(result.clock, 1);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return clock.getSatisfaction();
  }

  tt_ClockMock   clock;
  tt_StaleMarker staleMarker;
}
#+end_src

* Strings

** ~Strings~

#+begin_src c :tangle build/Typist.pk3/zscript/strings/strings.zs

// Represents a set of strings.
class tt_Strings
{
  static tt_Strings of()
  {
    let result = new("tt_Strings");
    return result;
  }

  static tt_Strings ofOne(String s)
  {
    let result = new("tt_Strings");
    result.add(s);
    return result;
  }

  uint size() const
  {
    return _strings.size();
  }

  string at(uint i) const
  {
    return _strings[i];
  }

  bool contains(String str) const
  {
    uint foundIndex = _strings.Find(str);
    bool isFound    = (foundIndex != size());

    return isFound;
  }

  void add(String str)
  {
    _strings.push(str);
  }

  private Array<String> _strings;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let strings = tt_Strings.of();
  let size    = strings.size();

  it("tt_Strings: New Strings is empty", AssertEval(size, "==", 0));
}
{
  let strings = tt_Strings.of();
  let str     = "a";

  strings.add(str);
  let size = strings.size();

  it("tt_Strings: Element must be added", AssertEval(size, "==", 1));
  it("tt_Strings: Element must be the same", Assert(strings.at(0) == str));
}
#+end_src

* Target

** ~DeathReporter~

#+begin_src c :tangle build/Typist.pk3/zscript/target/death_reporter.zs

// Implements tt_TargetSource by collecting reports of
// dead things as a list of DisabledTargets.
class tt_DeathReporter : tt_TargetSource
{
  static tt_DeathReporter of()
  {
    let result = new("tt_DeathReporter");

    result._targets = tt_Targets.of();

    return result;
  }

  void reportDead(Actor thing)
  {
    let newDisabled = tt_Target.of(thing);
    _targets.add(newDisabled);
  }

  override tt_Targets getTargets()
  {
    let result = _targets;
    _targets = tt_Targets.of();
    return result;
  }

  private tt_Targets _targets;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let _deathReporter = tt_DeathReporter.of();
  let targetsBefore  = _deathReporter.getTargets();
  it("tt_DeathReporter: No targets before reporting",
    AssertEval(targetsBefore.size(), "==", 0));

  let something = spawn("DoomImp", (0, 0, 0));
  _deathReporter.reportDead(something);
  let targetsAfter = _deathReporter.getTargets();
  it("tt_DeathReporter: Single target after reporting",
    AssertEval(targetsAfter.size(), "==", 1));

  let targetsAfterAfter = _deathReporter.getTargets();
  it("tt_DeathReporter: No new targets",
    AssertEval(targetsAfterAfter.size(), "==", 0));

  cleanUpSpawned();
}
#+end_src

** ~Target~

#+begin_src c :tangle build/Typist.pk3/zscript/target/target.zs

// Represents an attack target.
class tt_Target
{
  static tt_Target of(Actor a)
  {
    let result = new("tt_Target");

    result._actor = a;

    return result;
  }

  // Get position in game space of this target.
  tt_Origin getPosition() const
  {
    Vector3 position = _actor.pos;
    position.z += _actor.height / 2;

    let result = tt_Origin.of(position);

    return result;
  }

  bool isEqual(tt_Target other) const
  {
    return other._actor == _actor;
  }

  Actor getActor() const
  {
    return _actor;
  }

  private Actor _actor;
}
#+end_src

** ~TargetRadar~

#+begin_src c :tangle build/Typist.pk3/zscript/target/target_radar.zs

// Implements tt_TargetSource by scanning the world around the
// supplied origin for actors suitable to be targets.
class tt_TargetRadar : tt_TargetSource
{
  static tt_TargetRadar of(tt_OriginSource originSource)
  {
    let result = new("tt_TargetRadar");

    result._originSource = originSource;

    return result;
  }

  override tt_Targets getTargets()
  {
    let result = tt_Targets.of();

    let origin = _originSource.getOrigin().getVector();

    let iterator = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
    Actor a;
    while (a = Actor(iterator.Next()))
    {
      if (tt_Math.isInEffectiveRange(a.pos, origin) && isSuitableForTargeting(a))
      {
        result.add(tt_Target.of(a));
      }
    }

    return result;
  }

  private static bool isSuitableForTargeting(Actor a)
  {
    bool isMonster    = a.bIsMonster;
    bool isAlive      = (a.Health > 0);
    bool isFriendly   = a.bFriendly;
    bool isMissile    = a.bMissile;
    bool isDamageable = !a.bNoDamage;
    bool isNoDamage   = (a.Damage == 0);
    bool isMissileSuitable = false;
    bool isSuitable   = (  (  (isMonster && isDamageable)
                           || (isMissile && !isNoDamage && isMissileSuitable)
                           )
                        && isAlive
                        && !isFriendly
                        );

    return isSuitable;
  }

  private tt_OriginSource _originSource;
}
#+end_src

*** Test

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_TargetRadar: checkActorsAround";
  let env = tt_TargetRadarTestEnvironment.of();

  Array<Actor> actors =
  {
    spawn("DoomImp", ( 5,  0,  0)),
    spawn("DoomImp", (-5,  0,  0)),
    spawn("DoomImp", ( 0,  5,  0)),
    spawn("DoomImp", ( 0, -5,  0)),
    spawn("DoomImp", ( 0,  0,  5)),
    spawn("DoomImp", ( 0,  0, -5))
  };

  env.originSource.expect_getOrigin(tt_Origin.of((0, 0, 0)));

  let targets  = env.targetRadar.getTargets();
  uint nActors = actors.size();
  for (uint i = 0; i < nActors; ++i)
  {
    let a = tt_Target.of(actors[i]);
    it(string.format(tag .. ": actor %d is present in list", i),
       Assert(targets.contains(a)));
  }

  assertSatisfaction(env.originSource.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_TargetRadar: checkDistantActor";
  let env = tt_TargetRadarTestEnvironment.of();

  env.originSource.expect_getOrigin(tt_Origin.of((0, 0, 0)));

  let distantActor  = spawn("DoomImp", (1000, 0, 0));
  let distantTarget = tt_Target.of(distantActor);
  let targets       = env.targetRadar.getTargets();

  it(tag .. ": distant actor is not in list",
     AssertFalse(targets.contains(distantTarget)));

  assertSatisfaction(env.originSource.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_TargetRadar: checkNonLivingActor";
  let env = tt_TargetRadarTestEnvironment.of();

  env.originSource.expect_getOrigin(tt_Origin.of((0, 0, 0)));

  let nonLiving       = spawn("Medikit", (1, 0, 0));
  let targets         = env.targetRadar.getTargets();
  let nonLivingTarget = tt_Target.of(nonLiving);

  it(tag .. ": non-living actor is not in list",
     AssertFalse(targets.contains(nonLivingTarget)));

  assertSatisfaction(env.originSource.getSatisfaction(), tag);
  cleanUpSpawned();
}
{
  let tag = "tt_TargetRadar: checkDeadActor";
  let env = tt_TargetRadarTestEnvironment.of();

  env.originSource.expect_getOrigin(tt_Origin.of((0, 0, 0)));

  let deadActor  = spawnDead("DoomImp", (1, 0, 0));
  let targets    = env.targetRadar.getTargets();
  let deadTarget = tt_Target.of(deadActor);

  it(tag .. ": dead actor is not in list",
     AssertFalse(targets.contains(deadTarget)));

  assertSatisfaction(env.originSource.getSatisfaction(), tag);
  cleanUpSpawned();
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_TargetRadarTestEnvironment
{
  static tt_TargetRadarTestEnvironment of()
  {
    let result = new("tt_TargetRadarTestEnvironment");
    result.originSource = tt_OriginSourceMock.of();
    result.targetRadar  = tt_TargetRadar.of(result.originSource);
    return result;
  }

  tt_OriginSourceMock originSource;
  tt_TargetRadar      targetRadar;
}
#+end_src

** ~TargetSource~

#+begin_src c :tangle build/Typist.pk3/zscript/target/target_source.zs

// This interface represents a source of targets.
// See: tt_Target.
class tt_TargetSource abstract
{
  abstract tt_Targets getTargets();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_TargetSourceMock : tt_TargetSource
{
  static tt_TargetSourceMock of() { return new("tt_TargetSourceMock"); }

  override tt_Targets getTargets()
  {
    ++_mock_getTargets_called;
    return _mock_getTargets;
  }

  void expect_getTargets(tt_Targets value, int expected = 1)
  {
    _mock_getTargets = value;
    _mock_getTargets_expected = expected;
    _mock_getTargets_called = 0;
  }

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": getTargets",
            _mock_getTargets_expected == _mock_getTargets_called);
  }

  private tt_Targets _mock_getTargets;
  private int _mock_getTargets_expected;
  private int _mock_getTargets_called;
}
#+end_src

** ~TargetSourceCache~

#+begin_src c :tangle build/Typist.pk3/zscript/target/target_source_cache.zs

// Implements tt_TargetSource by calling other tt_TargetSource only
// if previously received target is stale.
class tt_TargetSourceCache : tt_TargetSource
{
  static tt_TargetSourceCache of(tt_TargetSource targetSource,
                                 tt_StaleMarker staleMarker)
  {
    let result = new("tt_TargetSourceCache");

    result._targetSource = targetSource;
    result._staleMarker  = staleMarker;

    return result;
  }

  override tt_Targets getTargets()
  {
    if (_staleMarker.isStale())
    {
      _targets = _targetSource.getTargets();
    }

    return _targets;
  }

  private tt_TargetSource _targetSource;
  private tt_StaleMarker  _staleMarker;

  private tt_Targets _targets;
}
#+end_src

** ~TargetSourcePruner~

#+begin_src c :tangle build/Typist.pk3/zscript/target/target_source_pruner.zs

// Implements tt_TargetSource by pruning other tt_TargetSource from
// targets with null actors.
class tt_TargetSourcePruner : tt_TargetSource
{
  static tt_TargetSourcePruner of(tt_TargetSource targetSource)
  {
    let result = new("tt_TargetSourcePruner");
    result._targetSource = targetSource;
    return result;
  }

  override tt_Targets getTargets()
  {
    let targets = _targetSource.getTargets();

    tt_Targets result = tt_Targets.of();

    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      tt_Target target = targets.at(i);
      if (target.getActor() != NULL)
      {
        result.add(target);
      }
    }

    return result;
  }

  private tt_TargetSource _targetSource;
}
#+end_src

** ~Targets~

#+begin_src c :tangle build/Typist.pk3/zscript/target/targets.zs

// Represent a list of Targets.
class tt_Targets
{
  static tt_Targets of()
  {
    let result = new("tt_Targets");
    return result;
  }

  // Returns a target in this list.
  tt_Target at(uint index) const
  {
    return _targets[index];
  }

  // Returns a number of targets in this list.
  uint size() const
  {
    return _targets.size();
  }

  // Returns true if this target list contains a target with the specified id.
  bool contains(tt_Target target) const
  {
    return find(target) != size();
  }

  bool isEmpty() const
  {
    return (size() == 0);
  }

  // Adds a target to this list.
  void add(tt_Target target)
  {
    _targets.push(target);
  }

  // Searches for a target with a particular id.
  // Returns index on success, the total number of targets on failure.
  private uint find(tt_Target target) const
  {
    uint nTargets = size();
    for (uint i = 0; i < nTargets; ++i)
    {
      if (_targets[i].isEqual(target)) { return i; }
    }
    return nTargets;
  }

  private Array<tt_Target> _targets;
}
#+end_src

* Target Widget

** ~Projector~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/projector.zs

// Implements TargetWidgetSource by accumulating Target Widgets.
// Attention: this class has no tests. Modifications must be checked manually.
class tt_Projector : tt_TargetWidgetSource
{
  static tt_Projector of(tt_KnownTargetSource knownTargetSource,
                         tt_PlayerSource playerSource)
  {
    let result = new("tt_Projector");

    result._knownTargetSource = knownTargetSource;
    result._playerSource      = playerSource;
    result._cvarRenderer      = tt_Cvar.of(playerSource, "vid_rendermode");

    result._glProjection = new("tt_le_GlScreen");
    result._swProjection = new("tt_le_SwScreen");

    return result;
  }

  override tt_TargetWidgets getWidgets(RenderEvent event)
  {
    let targets = _knownTargetSource.getTargets();
    let info    = _playerSource.getInfo();
    let result  = tt_TargetWidgets.of();

    prepareProjection();

    _projection.CacheResolution();
    _projection.CacheFov(info.fov);
    _projection.OrientForRenderOverlay(event);
    _projection.BeginProjection();

    tt_le_Viewport viewport;
    viewport.FromHud();

    uint nTargets = targets.size();
    for (uint i = 0; i < nTargets; ++i)
    {
      let target = targets.at(i);

      let targetActor = target.getTarget().getActor();
      if (targetActor == NULL)
      {
        continue;
      }

      Vector3 targetPos = target.getTarget().getPosition().getVector();
      Vector2 position;
      bool    isPositionSuccessful;
      [position, isPositionSuccessful] = makeDrawPos(targetPos, viewport);

      if (isPositionSuccessful)
      {
        let widget = tt_TargetWidget.of(target, position);
        result.add(widget);
      }
    }

    return result;
  }

  // Calculates the screen position (draw position).
  // Returns screen position and success flag.
  private ui Vector2, bool makeDrawPos(Vector3 targetPos, tt_le_Viewport viewport)
  {
    _projection.ProjectWorldPos(targetPos);

    if(!_projection.IsInFront())
    {
      return (0, 0), false;
    }

    Vector2 drawPos = viewport.SceneToWindow(_projection.ProjectToNormal());

    return drawPos, true;
  }

  private void prepareProjection()
  {
    if(_cvarRenderer.isDefined())
    {
      switch (_cvarRenderer.getInt())
      {
      case 0:
      case 1:  _projection = _swProjection; break;
      default: _projection = _glProjection; break;
      }
    }
    else // cannot get render mode.
    {
      _projection = _glProjection;
    }
  }

  private tt_KnownTargetSource _knownTargetSource;
  private tt_PlayerSource      _playerSource;

  private tt_le_ProjScreen _projection;
  private tt_le_GlScreen   _glProjection;
  private tt_le_SwScreen   _swProjection;

  private transient bool _isInitialized;

  private tt_Cvar _cvarRenderer;
}
#+end_src

** ~SorterByDistance~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/sorter_by_distance.zs

// Implements TargetWidgetSource by taking another TargetWidgetSource
// and sorting the widgets from it by a distance to origin from OriginSource.
//
// Sorting algorithm: merge sort
// https://en.wikipedia.org/wiki/Merge_sort
class tt_SorterByDistance : tt_TargetWidgetSource
{
  static tt_SorterByDistance of(tt_TargetWidgetSource targetWidgetSource,
                                tt_OriginSource originSource)
  {
    let result = new("tt_SorterByDistance");

    result._targetWidgetSource = targetWidgetSource;
    result._originSource       = originSource;

    return result;
  }

  override tt_TargetWidgets getWidgets(RenderEvent event)
  {
    let widgets = _targetWidgetSource.getWidgets(event);
    let origin  = _originSource.getOrigin().getVector();
    let sorted  = sort(widgets, origin);

    return sorted;
  }

  static tt_TargetWidgets sort(tt_TargetWidgets widgets, Vector3 origin)
  {
    let result    = widgets;
    let workplace = widgets.copy();

    TopDownSplitMerge(workplace, 0, widgets.size(), result, origin);

    return result;
  }

  private static void TopDownSplitMerge(tt_TargetWidgets B,
                                        uint             begin,
                                        uint             end,
                                        tt_TargetWidgets A,
                                        Vector3          origin)
  {
    if ((end - begin) < 2) // if run size == 1 consider it sorted
    {
      return;
    }

    // split the run longer than 1 item into halves
    uint middle = (end + begin) / 2; // mid point

    // recursively sort both runs from array A into B
    TopDownSplitMerge(A, begin,  middle, B, origin); // sort the left  run
    TopDownSplitMerge(A, middle,    end, B, origin); // sort the right run

    // merge the resulting runs from array B into A
    TopDownMerge(B, begin, middle, end, A, origin);
  }

  private static void TopDownMerge(tt_TargetWidgets A,
                                   uint             begin,
                                   uint             middle,
                                   uint             end,
                                   tt_TargetWidgets B,
                                   Vector3          origin)
  {
    uint i = begin;
    uint j = middle;

    // While there are elements in the left or right runs...
    for (uint k = begin; k < end; ++k)
    {
      // If left run head exists and is >= existing right run head.
      if (i < middle
          && (j >= end || A.at(i).getDistanceTo(origin) >= A.at(j).getDistanceTo(origin)))
      {
        B.set(k, A.at(i));
        ++i;
      }
      else
      {
        B.set(k, A.at(j));
        ++j;
      }
    }
  }

  private tt_TargetWidgetSource _targetWidgetSource;
  private tt_OriginSource       _originSource;
}
#+end_src

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_SorterByDistance : checkEmpty";

  let before = tt_TargetWidgets.of();
  let origin = tt_Origin.of((0, 0, 0));
  let after  = tt_SorterByDistance.sort(before, origin.getVector());

  it(tag .. ": empty collection must remain empty",
     AssertEval(after.size(), "==", 0));
}
{
  let tag = "tt_SorterByDistance : checkSorted";

  let origin = tt_Origin.of((0, 0, 0));
  let before = tt_TargetWidgets.of();
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 2))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 1))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 0))));

  it(tag .. ": Before: sorted",
     Assert(tt_SorterByDistanceTest.isSorted(before, origin.getVector())));

  let after = tt_SorterByDistance.sort(before, origin.getVector());

  it(tag .. ": size of collection must the same",
     AssertEval(after.size(), "==", before.size()));
  it(tag .. ": contains same elements",
     Assert(tt_SorterByDistanceTest.isSameElements(before, after)));
  it(tag .. ": after: sorted",
     Assert(tt_SorterByDistanceTest.isSorted(after, origin.getVector())));

  cleanUpSpawned();
}
{
  let tag = "tt_SorterByDistance : checkReverse";

  let origin = tt_Origin.of((0, 0, 0));
  let before = tt_TargetWidgets.of();
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 0))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 1))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 2))));

  it(tag .. ": before: not sorted",
     Assert(!tt_SorterByDistanceTest.isSorted(before, origin.getVector())));

  let after = tt_SorterByDistance.sort(before, origin.getVector());

  it(tag .. ": size of collection must the same",
     AssertEval(after.size(), "==", before.size()));
  it(tag .. ": contains same elements",
     Assert(tt_SorterByDistanceTest.isSameElements(before, after)));
  it(tag .. ": after: sorted",
     Assert(tt_SorterByDistanceTest.isSorted(after, origin.getVector())));

  cleanUpSpawned();
}
{
  let tag = "tt_SorterByDistance : middle";

  let origin = tt_Origin.of((0, 0, 0));
  let before = tt_TargetWidgets.of();
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 1))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 2))));
  before.add(tt_SorterByDistanceTest.createAtPosition(spawn("Demon", (0, 0, 0))));

  it(tag .. ": before: not sorted",
     Assert(!tt_SorterByDistanceTest.isSorted(before, origin.getVector())));

  let after = tt_SorterByDistance.sort(before, origin.getVector());

  it(tag .. ": size of collection must the same",
     AssertEval(after.size(), "==", before.size()));
  it(tag .. ": contains same elements",
     Assert(tt_SorterByDistanceTest.isSameElements(before, after)));
  it(tag .. ": after: sorted",
     Assert(tt_SorterByDistanceTest.isSorted(after, origin.getVector())));

  cleanUpSpawned();
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_SorterByDistanceTest
{
  static bool isSorted(tt_TargetWidgets targetWidgets, vector3 origin)
  {
    uint nWidgets = targetWidgets.size();

    if (nWidgets < 2) return true;

    for (uint i = 1; i < nWidgets; ++i)
    {
      let prevDistance = targetWidgets.at(i - 1).getDistanceTo(origin);
      let thisDistance = targetWidgets.at(i    ).getDistanceTo(origin);

      if (prevDistance < thisDistance) return false;
    }

    return true;
  }

  static bool isSameElements(tt_TargetWidgets t1, tt_TargetWidgets t2)
  {
    uint nWidgets1 = t1.size();
    uint nWidgets2 = t2.size();

    if (nWidgets1 != nWidgets2) return false;

    for (uint i = 0; i < nWidgets1; ++i)
      if (!t2.containsWidget(t1.at(i))) return false;

    for (uint i = 0; i < nWidgets2; ++i)
      if (!t1.containsWidget(t2.at(i))) return false;

    return true;
  }

  static tt_TargetWidget createAtPosition(Actor anActor)
  {
    let target      = tt_Target.of(anActor);
    let question    = tt_QuestionMock.of();
    let knownTarget = tt_KnownTarget.of(target, question);
    let widget      = tt_TargetWidget.of(knownTarget, (0, 0));

    return widget;
  }
}
#+end_src

** ~TargetWidget~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/target_widget.zs

// Represents a target displayed on the screen.
class tt_TargetWidget
{
  static tt_TargetWidget of(tt_KnownTarget target, Vector2 position)
  {
    let result = new("tt_TargetWidget");

    result._target   = target;
    result._position = position;

    return result;
  }

  tt_KnownTarget getTarget() const
  {
    return _target;
  }

  Vector2 getPosition() const
  {
    return _position;
  }

  double getDistanceTo(Vector3 other)
  {
    let worldPosition = _target.getTarget().getPosition().getVector();
    let distance      = (worldPosition - other).Length();

    return distance;
  }

  void setPosition(Vector2 position)
  {
    _position = position;
  }

  private tt_KnownTarget _target;
  private Vector2        _position;
}
#+end_src

** ~TargetWidgetRegistry~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/target_widget_registry.zs

// Implements TargetWidgetSource by storing target widgets, getting
// new widgets from the source, and updating the coordinates of the widgets that
// are already registered.
class tt_TargetWidgetRegistry : tt_TargetWidgetSource
{
  static tt_TargetWidgetRegistry of(tt_TargetWidgetSource source)
  {
    let result = new("tt_TargetWidgetRegistry");

    result._source   = source;
    result._registry = tt_TargetWidgets.of();

    return result;
  }

  override tt_TargetWidgets getWidgets(RenderEvent event)
  {
    let widgets     = _source.getWidgets(event);
    let newRegistry = tt_TargetWidgets.of();

    uint nWidgets = widgets.size();
    for (uint i = 0; i < nWidgets; ++i)
    {
      let widget   = widgets.at(i);
      let target   = widget.getTarget().getTarget();
      let existing = _registry.find(target);

      if (existing == NULL)
      {
        newRegistry.add(widget);
      }
      else
      {
        newRegistry.add(existing);
        let newPosition      = widget.getPosition();
        let existingPosition = existing.getPosition();
        let middle           = (newPosition * 0.3 + existingPosition * 0.7);
        existing.setPosition(middle);
      }
    }

    // Widgets that are not new or not updated are thrown away.
    _registry = newRegistry;

    return _registry;
  }

  private tt_TargetWidgetSource _source;
  private tt_TargetWidgets      _registry;
}
#+end_src

** ~TargetWidgetSource~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/target_widget_source.zs

// This interface provides a source of target widgets.
class tt_TargetWidgetSource abstract
{
  // Get a list of target widgets.
  // Returns a list of target widgets.
  ui abstract tt_TargetWidgets getWidgets(RenderEvent event);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_TargetWidgetSourceMock : tt_TargetWidgetSource
{
  static tt_TargetWidgetSourceMock of() { return new("tt_TargetWidgetSourceMock"); }

  override tt_TargetWidgets getWidgets(RenderEvent event)
  {
    ++_mock_getWidgets_called;
    return _mock_getWidgets;
  }

  void expect_getWidgets(tt_TargetWidgets value, int expected = 1)
  {
    _mock_getWidgets = value;
    _mock_getWidgets_expected = expected;
    _mock_getWidgets_called = 0;
  }

  private tt_TargetWidgets _mock_getWidgets;
  private int _mock_getWidgets_expected;
  private int _mock_getWidgets_called;
}
#+end_src

** ~TargetWidget~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/target_widgets.zs

// Represents a list of target widgets.
class tt_TargetWidgets
{
  static tt_TargetWidgets of()
  {
    let result = new("tt_TargetWidgets");
    return result;
  }

  // Returns a target in this list.
  tt_TargetWidget at(uint index) const
  {
    return _widgets[index];
  }

  // Returns a number of targets in this list.
  uint size() const
  {
    return _widgets.size();
  }

  tt_TargetWidget find(tt_Target id) const
  {
    foreach (widget : _widgets)
      if (widget.getTarget().getTarget().isEqual(id)) return widget;

    return NULL;
  }

  bool containsWidget(tt_TargetWidget widget) const
  {
    uint nWidgets = size();
    for (uint i = 0; i < nWidgets; ++i)
    {
      if (widget == at(i))
      {
        return true;
      }
    }

    return false;
  }

  tt_TargetWidgets copy() const
  {
    let result = tt_TargetWidgets.of();
    result._widgets.Reserve(size());
    result._widgets.Copy(_widgets);

    return result;
  }

  // Adds a target to this list.
  void add(tt_TargetWidget widget)
  {
    _widgets.push(widget);
  }

  void set(uint i, tt_TargetWidget widget)
  {
    _widgets[i] = widget;
  }

  private Array<tt_TargetWidget> _widgets;
}
#+end_src

** ~VisibilityFilter~

#+begin_src c :tangle build/Typist.pk3/zscript/target_widget/visibility_filter.zs

// Implements TargetWidgetSource by taking target widgets from
// source and removing widgets that represent targets not visible by the player.
class tt_VisibilityFilter : tt_TargetWidgetSource
{
  static tt_VisibilityFilter of(tt_TargetWidgetSource widgetSource,
                                tt_PlayerSource playerSource)
  {
    let result = new("tt_VisibilityFilter");

    result._widgetSource = widgetSource;
    result._playerSource = playerSource;

    return result;
  }

  override tt_TargetWidgets getWidgets(RenderEvent event)
  {
    let pawn = _playerSource.getPawn();
    if (pawn == NULL) { return NULL; }

    let widgets = _widgetSource.getWidgets(event);
    if (widgets == NULL) { return NULL; }

    tt_TargetWidgets result = tt_TargetWidgets.of();

    uint nWidgets = widgets.size();
    for (uint i = 0; i < nWidgets; ++i)
    {
      let widget = widgets.at(i);

      if (isVisible(widget, pawn))
      {
        result.add(widget);
      }
    }

    return result;
  }

  // Play-const hack: Actor.isVisible(...) is not const, but should be.
  private play bool isVisible(tt_TargetWidget widget, PlayerPawn pawn) const
  {
    let  targetActor = widget.getTarget().getTarget().getActor();
    bool visible     = pawn.IsVisible(targetActor, false);

    return visible;
  }

  const DISTANCE = 4000.0;

  private tt_TargetWidgetSource _widgetSource;
  private tt_PlayerSource       _playerSource;
}
#+end_src

* View

** ~View~

#+begin_src c :tangle build/Typist.pk3/zscript/view/view.zs

// This interface represents a view - something that displays something.
class tt_View abstract
{
  ui abstract void draw(RenderEvent event);
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_ViewMock : tt_View
{
  static tt_ViewMock of() { return new("tt_ViewMock"); }

  override void draw(RenderEvent event)
  {
    ++_mock_draw_called;
  }

  void expect_draw(int expected = 1)
  {
    _mock_draw_expected = expected;
    _mock_draw_called = 0;
  }

  private int _mock_draw_expected;
  private int _mock_draw_called;
}
#+end_src

** ~Views~

#+begin_src c :tangle build/Typist.pk3/zscript/view/views.zs

// Implements View by allowing several Views to be drawn.
class tt_Views : tt_View
{
  static tt_Views of(Array<tt_View> views)
  {
    let result = new("tt_Views");
    result._views.move(views);
    return result;
  }

  override void draw(RenderEvent event)
  {
    foreach (view : _views)
      view.draw(event);
  }

  private Array<tt_View> _views;
}
#+end_src

** ~Frame~

#+begin_src c :tangle build/Typist.pk3/zscript/view/frame.zs
class tt_Frame : tt_View
{
  static tt_Frame of(tt_ModeSource modeSource)
  {
    let result = new("tt_Frame");
    result._modeSource = modeSource;
    result._alphaInterpolator = tt_DoubleInterpolator.of();
    return result;
  }

  override void draw(RenderEvent event)
  {
    double destination = (_modeSource.getMode() == tt_Mode.Combat) ? 1.0 : 0.0;

    _alphaInterpolator.reset(destination, 0.1);
    // TODO: untie from framerate?
    _alphaInterpolator.update();

    double alpha = _alphaInterpolator.getValue();

    if (alpha ~== 0.0) return;

    let frameTexture = TexMan.checkForTexture("tt-frame", TexMan.Type_Any);
    int screenWidth  = Screen.getWidth();
    int screenHeight = Screen.getHeight();
    int frameWidth   = screenWidth / 32;

    Screen.drawTexture( frameTexture
                      , NOT_ANIMATED
                      , 0
                      , 0
                      , DTA_DestWidth     , frameWidth
                      , DTA_DestHeight    , screenHeight
                      , DTA_KeepRatio     , true
                      , DTA_VirtualWidth  , screenWidth
                      , DTA_VirtualHeight , screenHeight
                      , DTA_Alpha         , alpha
                      );

    Screen.drawTexture( frameTexture
                      , NOT_ANIMATED
                      , screenWidth - frameWidth
                      , 0
                      , DTA_FlipX         , true
                      , DTA_DestWidth     , frameWidth
                      , DTA_DestHeight    , screenHeight
                      , DTA_KeepRatio     , true
                      , DTA_VirtualWidth  , screenWidth
                      , DTA_VirtualHeight , screenHeight
                      , DTA_Alpha         , alpha
                      );
  }

  const NOT_ANIMATED = 0; // false

  private tt_ModeSource _modeSource;
  private tt_DoubleInterpolator _alphaInterpolator;
}
#+end_src

#+begin_src c :tangle build/Typist.pk3/zscript/interpolator/double_interpolator.zs

class tt_DoubleInterpolator
{
  static tt_DoubleInterpolator of() { return new("tt_DoubleInterpolator"); }

  ui void update()
  {
    _currentValue = (_destination > _currentValue)
      ? min(_destination, _currentValue + _step)
      : max(_destination, _currentValue - _step);
  }

  ui double getValue() const { return _currentValue; }

  ui void reset(double destination, double step)
  {
    _destination = destination;
    _step = step;
  }

  private ui double _destination;
  private ui double _currentValue;
  private ui double _step;
}
#+end_src

** ~ConditionalView~

#+begin_src c :tangle build/Typist.pk3/zscript/view/conditional_view.zs

// Implements a view by taking another view, and calling draw()
// only if conditions are met.
//
// The list of conditions:
// - not in a menu
// - automap is closed
//
// Attention! This class reads data from global scope.
class tt_ConditionalView : tt_View
{
  static tt_ConditionalView of(tt_View view)
  {
    let result = new("tt_ConditionalView");
    result._view = view;
    return result;
  }

  override void draw(RenderEvent event)
  {
    if (!menuActive && !automapActive) _view.draw(event);
  }

  private tt_View _view;
}
#+end_src

** ~Drawing~

#+begin_src c :tangle build/Typist.pk3/zscript/view/drawing.zs

// Namespace for common drawing functions.
class tt_Drawing ui
{
  static int getWidthForTarget(String question, string answer, int scale)
  {
    Font fnt         = NewSmallFont;
    int  width       = max(fnt.StringWidth(question), fnt.StringWidth(answer));
    int  borderWidth = makeBorderWidth(width) * scale;
    return borderWidth;
  }

  static void drawTarget(vector2 pos,
                         string  question,
                         string  answer,
                         int     scale,
                         bool    isCentered,
                         int     color)
  {
    Font fnt          = NewSmallFont;
    int  screenWidth  = Screen.GetWidth()  / scale;
    int  screenHeight = Screen.GetHeight() / scale;

    let  position = pos / scale;
    int  height   = fnt.GetHeight();
    int  width    = max(fnt.StringWidth(question), fnt.StringWidth(answer));

    double xStart = isCentered
                  ? (position.x - width / 2)
                  : position.x;
    int x = int(Clamp(xStart,     FRAME, screenWidth  - FRAME - width         ));
    int y = int(Clamp(position.y, FRAME, screenHeight - FRAME * 3 - height * 2));

    drawBoxes(x, y, width, height, screenWidth, screenHeight, color);
    drawText(x, y, height, fnt, question, answer, screenWidth, screenHeight);
  }

  static int getColorForMode(int mode)
  {
    return (mode == tt_Mode.Combat) ? COMBAT_COLOR : EXPLORE_COLOR;
  }

  private static int makeBorderWidth(int width)
  {
    int borderWidth  = FRAME * 2 + width;
    return borderWidth;
  }

  private static void drawBoxes(int x,
                                int y,
                                int width,
                                int lineHeight,
                                int screenWidth,
                                int screenHeight,
                                int color)
  {
    // TODO: replace with null?
    // Texture is necessary for drawing, but in fact it isn't used.
    // The color is specified with DTA_FillColor.
    let dummyTexture = TexMan.CheckForTexture("tt-white", TexMan.Type_Any);

    drawBox(dummyTexture, x, y, width, lineHeight, screenWidth, screenHeight, RGB_GOLD);

    int lowerY = y + lineHeight + FRAME * 2;
    drawBox(dummyTexture, x, lowerY, width, lineHeight, screenWidth, screenHeight, color);
  }

  private static void drawBox( TextureID tex
              , int x
              , int y
              , int width
              , int lineHeight
              , int screenWidth
              , int screenHeight
              , int color
              )
  {
    // TODO: replace drawTexture with drawShapeFill
    // Screen.drawShapeFill(Color col, double amount, Shape2D s)

    { // border
      int borderX      = x - FRAME;
      int borderY      = y - FRAME;
      int borderWidth  = makeBorderWidth(width);
      int borderHeight = FRAME * 2 + lineHeight;

      Screen.DrawTexture( tex
                        , NOT_ANIMATED
                        , borderX
                        , borderY
                        , DTA_DestWidth     , borderWidth
                        , DTA_DestHeight    , borderHeight
                        , DTA_FillColor     , color
                        , DTA_KeepRatio     , true
                        , DTA_VirtualWidth  , screenWidth
                        , DTA_VirtualHeight , screenHeight
                        , DTA_Alpha         , BORDER_ALPHA
                        );
    }

    { // background
      int backgroundX      = x - PADDING;
      int backgroundY      = y - PADDING;
      int backgroundWidth  = PADDING * 2 + width;
      int backgroundHeight = PADDING * 2 + lineHeight;

      Screen.DrawTexture( tex
                        , NOT_ANIMATED
                        , backgroundX
                        , backgroundY
                        , DTA_DestWidth     , backgroundWidth
                        , DTA_DestHeight    , backgroundHeight
                        , DTA_FillColor     , RGB_BLACK
                        , DTA_KeepRatio     , true
                        , DTA_VirtualWidth  , screenWidth
                        , DTA_VirtualHeight , screenHeight
                        , DTA_Alpha         , BACKGROUND_ALPHA
                        );
    }
  }

  private static void drawText( int    x
               , int    y
               , int    height
               , Font   fnt
               , string question
               , string answer
               , int    screenWidth
               , int    screenHeight
               )
  {
    Screen.DrawText( fnt
                   , Font.CR_WHITE
                   , x
                   , y
                   , "$" .. question
                   , DTA_KeepRatio     , true
                   , DTA_VirtualWidth  , screenWidth
                   , DTA_VirtualHeight , screenHeight
                   );
    Screen.DrawText( fnt
                   , Font.CR_WHITE
                   , x
                   , y + height + FRAME * 2
                   , "$" .. answer
                   , DTA_KeepRatio     , true
                   , DTA_VirtualWidth  , screenWidth
                   , DTA_VirtualHeight , screenHeight
                   );
  }

  const BORDER       = 1;
  const PADDING      = 2;
  const FRAME        = BORDER + PADDING;

  const NOT_ANIMATED = 0; // false

  const RGB_BLACK    = 0x000000;
  const RGB_GOLD     = 0xF4AF31;

  const BORDER_ALPHA     = 0.2;
  const BACKGROUND_ALPHA = 0.2;

  const COMBAT_COLOR  = 0xFF0000;
  const EXPLORE_COLOR = 0x999999;
}
#+end_src

** ~InfoPanel~

#+begin_src c :tangle build/Typist.pk3/zscript/view/info_panel.zs

// Implements View by collecting and displaying various information:
// - game mode
// - list of commands
// - current input string
// - several targets
class tt_InfoPanel : tt_View
{
  static tt_InfoPanel of(tt_ModeSource        modeSource,
                         tt_AnswerSource      answerSource,
                         tt_Activatable       activatable,
                         tt_KnownTargetSource knownTargetSource,
                         tt_Settings          settings,
                         tt_PlayerSource      playerSource)
  {
    let result = new("tt_InfoPanel");

    result._modeSource   = modeSource;
    result._answerSource = answerSource;
    result._activatable  = activatable;
    result._targetSource = knownTargetSource;
    result._settings     = settings;
    result._playerSource = playerSource;

    return result;
  }

  override void draw(RenderEvent _)
  {
    int     screenWidth = Screen.GetWidth();
    int     xStart      = screenWidth / 2;
    Vector2 position    = (xStart, Y_START);

    drawTargets (position);
    drawCommands(position);
  }

  private ui void drawTargets(vector2 xy)
  {
    int scale       = _settings.getScale();
    int screenWidth = Screen.GetWidth();
    int x           = int(xy.x + HORIZONTAL_MARGIN);
    int y           = int(xy.y + (VERTICAL_MARGIN * scale));
    let targets     = _targetSource.getTargets();
    let answer      = _answerSource.getAnswer();
    let nTargets    = targets.size();
    let player      = _playerSource.getPawn();
    int mode        = _modeSource.getMode();
    int color       = tt_Drawing.getColorForMode(mode);

    for (uint i = 0; i < nTargets; ++i)
    {
      let target = targets.at(i);

      if (!isVisible(player, target.getTarget().getActor())) continue;

      let    question       = target.getQuestion();
      string questionString = question.getDescription();
      string hintedAnswer   = question.getHintFor(answer);
      int    targetWidth    = tt_Drawing.getWidthForTarget(questionString,
                                                           hintedAnswer,
                                                           scale);

      if (x + targetWidth > screenWidth) return;

      vector2 position = (x, y);
      tt_Drawing.drawTarget(position,
                            questionString,
                            hintedAnswer,
                            scale,
                            NOT_CENTERED,
                            color);

      x += targetWidth + 2;
    }
  }

  private ui void drawCommands(vector2 xy)
  {
    int  scale       = _settings.getScale();
    let  commands    = _activatable.getCommands();
    int  screenWidth = Screen.GetWidth();
    uint nCommands   = commands.size();
    int  x           = int(xy.x - HORIZONTAL_MARGIN);
    int  y           = int(xy.y + (VERTICAL_MARGIN * scale));
    let  answer      = _answerSource.getAnswer().getString();
    int  mode        = _modeSource.getMode();
    int  color       = tt_Drawing.getColorForMode(mode);

    for (uint i = 0; i < nCommands; ++i)
    {
      let command     = commands.at(i);
      int targetWidth = tt_Drawing.getWidthForTarget(command, answer, scale);

      if (x - targetWidth < 0) return;

      vector2 position = (x - targetWidth, y);
      tt_Drawing.drawTarget(position,
                            command,
                            answer,
                            scale,
                            NOT_CENTERED,
                            color);

      x -= targetWidth + 2;
    }
  }

  // Play-const hack: Actor.isVisible(...) is not const, but should be.
  private play bool isVisible(Actor player, Actor other) const
  {
    return player.isVisible(other, ALL_AROUND);
  }

  const Y_START = 10;

  const HORIZONTAL_MARGIN = 10;
  const VERTICAL_MARGIN   = 20;

  const NOT_CENTERED = 0; // false

  const ALL_AROUND = 1; // true

  private tt_ModeSource        _modeSource;
  private tt_AnswerSource      _answerSource;
  private tt_Activatable       _activatable;
  private tt_KnownTargetSource _targetSource;
  private tt_Settings          _settings;
  private tt_PlayerSource      _playerSource;
}
#+end_src

** ~TargetOverlay~

#+begin_src c :tangle build/Typist.pk3/zscript/view/target_overlay.zs

// Implement tt_View by getting a list of Target Widgets and drawing them.
class tt_TargetOverlay : tt_View
{
  static tt_TargetOverlay of(tt_TargetWidgetSource targetWidgetSource,
                             tt_AnswerSource       answerSource,
                             tt_Settings           settings,
                             tt_ModeSource         modeSource)
  {
    let result = new("tt_TargetOverlay");

    result._targetWidgetSource = targetWidgetSource;
    result._answerSource       = answerSource;
    result._settings           = settings;
    result._modeSource         = modeSource;

    return result;
  }

  override void draw(RenderEvent event)
  {
    let widgets = _targetWidgetSource.getWidgets(event);
    let answer  = _answerSource.getAnswer();
    int mode    = _modeSource.getMode();
    int color   = tt_Drawing.getColorForMode(mode);
    int scale   = _settings.getScale();

    uint nWidgets = widgets.size();
    for (uint i = 0; i < nWidgets; ++i)
    {
      let    widget         = widgets.at(i);
      let    question       = widget.getTarget().getQuestion();
      string questionString = question.getDescription();
      string hintedAnswer   = question.getHintFor(answer);
      let    position       = widget.getPosition();

      tt_Drawing.drawTarget(position,
                            questionString,
                            hintedAnswer,
                            scale,
                            CENTERED,
                            color);
    }
  }

  const CENTERED = 1; // true

  private tt_TargetWidgetSource _targetWidgetSource;
  private tt_AnswerSource       _answerSource;
  private tt_Settings           _settings;
  private tt_ModeSource         _modeSource;
}
#+end_src

* World Changer

** ~WorldChanger~

#+begin_src c :tangle build/Typist.pk3/zscript/world_changer/world_changer.zs

// This interface represents entities that change the world state.
class tt_WorldChanger abstract
{
  play abstract void changeWorld();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_WorldChangerMock : tt_WorldChanger
{
  static tt_WorldChangerMock of() { return new("tt_WorldChangerMock"); }

  override void changeWorld()
  {
    ++_mock_changeWorld_called;
  }

  void expect_changeWorld(int expected = 1)
  {
    _mock_changeWorld_expected = expected;
    _mock_changeWorld_called = 0;
  }

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": changeWorld",
            _mock_changeWorld_expected == _mock_changeWorld_called);
  }

  private int _mock_changeWorld_expected;
  private int _mock_changeWorld_called;
}
#+end_src

** ~WorldChangers~

#+begin_src c :tangle build/Typist.pk3/zscript/world_changer/world_changers.zs

// Implements tt_WorldChanger by executing several instances of tt_WorldChanger.
class tt_WorldChangers : tt_WorldChanger
{
  static tt_WorldChangers of(Array<tt_WorldChanger> changers)
  {
    let result = new("tt_WorldChangers");
    result._changers.move(changers);
    return result;
  }

  static tt_WorldChangers ofNone() { return new("tt_WorldChangers"); }

  void add(tt_WorldChanger changer) { _changers.push(changer); }

  override void changeWorld()
  {
    foreach (changer : _changers)
      changer.changeWorld();
  }

  private Array<tt_WorldChanger> _changers;
}
#+end_src

** ~EnemySpeedController~

#+begin_src c :tangle build/Typist.pk3/zscript/world_changer/enemy_speed_controller.zs

// Implements tt_WorldChanger by slowing down enemies.
class tt_EnemySpeedController : tt_WorldChanger
{
  static tt_EnemySpeedController of(tt_TargetSource targetSource,
                                    tt_PlayerSource playerSource)
  {
    let result = new("tt_EnemySpeedController");
    result._targetSource = targetSource;
    result._playerSource = playerSource;
    return result;
  }

  override void changeWorld()
  {
    let  targets  = _targetSource.getTargets();
    uint nTargets = targets.size();
    int  player   = _playerSource.getNumber();

    for (uint i = 0; i < nTargets; ++i)
    {
      let enemy = targets.at(i).getActor();
      if (!tt_VelocityStorage.isSlowedDown(enemy, player))
        tt_VelocityStorage.slowDown(enemy, player);
    }
  }

  private tt_TargetSource _targetSource;
  private tt_PlayerSource _playerSource;
}
#+end_src

** ~ProjectileSpeedController~

#+begin_src c :tangle build/Typist.pk3/zscript/world_changer/projectile_speed_controller.zs

// Implements tt_WorldChanger by slowing down projectiles that fly towards the player.
//
// When a projectile is no longer flying towards the player, its speed is
// restored.
class tt_ProjectileSpeedController : tt_WorldChanger
{
  static tt_ProjectileSpeedController of(tt_OriginSource playerOriginSource,
                                         tt_PlayerSource playerSource)
  {
    let result = new("tt_ProjectileSpeedController");
    result._playerOriginSource = playerOriginSource;
    result._playerSource = playerSource;
    return result;
  }

  override void changeWorld()
  {
    let origin       = _playerOriginSource.getOrigin().getVector();
    let playerRadius = _playerSource.getPawn().radius;
    int player       = _playerSource.getNumber();

    foreach (Actor a : ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT))
      if (a.bMissile) controlProjectile(a, origin, playerRadius, player);
  }

  private play void controlProjectile(Actor a,
                                      Vector3 playerOrigin,
                                      double playerRadius,
                                      int player)
  {
    bool isInRange = tt_Math.isInEffectiveRange(a.pos, playerOrigin);

    if (isInRange && isMovingTowardsPlayer(a, playerOrigin, playerRadius))
    {
      if (!tt_VelocityStorage.isSlowedDown(a, player))
        tt_VelocityStorage.slowDown(a, player);
    }
    else if (tt_VelocityStorage.isSlowedDown(a, player))
    {
      tt_VelocityStorage.restoreVelocity(a, player);
    }
  }

  private play bool isMovingTowardsPlayer(Actor projectile,
                                          Vector3 playerPos,
                                          double playerRadius)
  {
    Vector3 vel = projectile.vel;
    if (vel == (0, 0, 0)) { return false; } // doesn't move

    double oldDistance = (projectile.pos - vel - playerPos).length();
    double distance    = (projectile.pos -       playerPos).length();

    if (distance > oldDistance) { return false; } // moves from player

    // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    Vector3 x10             = projectile.pos - playerPos;
    Vector3 prod            = tt_Math.crossProduct(vel, x10);
    double  lineDistance    = prod.length() / vel.length();
    double  hitDistance     = playerRadius + projectile.radius;
    bool    willTouchPlayer = (hitDistance >= lineDistance);

    return willTouchPlayer;
  }

  private tt_OriginSource _playerOriginSource;
  private tt_PlayerSource _playerSource;
}
#+end_src

** ~VelocityStorage~

#+begin_src c :tangle build/Typist.pk3/zscript/world_changer/velocity_storage.zs

// This is a helper class that allows storing the velocity.
// TODO: rewrite with a Behavior?
class tt_VelocityStorage : Inventory
{
  static bool isSlowedDown(Actor other, int byPlayer)
  {
    let storage = tt_VelocityStorage(other.findInventory("tt_VelocityStorage"));
    if (storage == NULL) return false;

    return storage._byWhichPlayer[byPlayer];
  }

  static void slowDown(Actor other, int byPlayer)
  {
    let storage = tt_VelocityStorage(other.findInventory("tt_VelocityStorage"));

    if (storage != NULL)
    {
      storage._byWhichPlayer[byPlayer] = true;
      return;
    }

    storage = tt_VelocityStorage(Actor.spawn("tt_VelocityStorage"));
    storage._velocity = other.vel;
    storage._speed    = other.speed;

    other.addInventory(storage);

    other.vel   *= VELOCITY_SCALE_FACTOR;
    other.speed *= VELOCITY_SCALE_FACTOR;
  }

  static void restoreVelocity(Actor other, int byPlayer)
  {
    let storage = tt_VelocityStorage(other.findInventory("tt_VelocityStorage"));

    storage._byWhichPlayer[byPlayer] = false;

    if (storage.countByPlayers() == 0)
    {
      other.vel   = storage._velocity;
      other.speed = storage._speed;

      other.removeInventory(storage);
      storage.destroy();
    }
  }

  private int countByPlayers()
  {
    int result = 0;
    foreach (byPlayer : _byWhichPlayer)
      result += byPlayer;
    return result;
  }

  // TODO: make velocity scale factor configurable for projectiles and enemies.
  // for actors it was 0.2.
  const VELOCITY_SCALE_FACTOR = 0.1;

  private vector3 _velocity;
  private double  _speed;
  private bool[MAXPLAYERS] _byWhichPlayer;
}
#+end_src

* Effect

** ~Effect~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/effect.zs

// Interface for any non-play effects.
class tt_Effect abstract
{
  abstract void doEffect();
}
#+end_src

*** Mock

#+begin_src c :tangle build/Typist.pk3Test/zscript/mocks.zs

class tt_EffectMock : tt_Effect
{
  static tt_EffectMock of() { return new("tt_EffectMock"); }

  override void doEffect()
  {
    ++_mock_doEffect_called;
  }

  void expect_doEffect(int expected = 1)
  {
    _mock_doEffect_expected = expected;
    _mock_doEffect_called = 0;
  }

  tt_Satisfaction getSatisfaction()
  {
    return tt_Satisfaction.of()
      .push(getClassName() .. ": doEffect",
            _mock_doEffect_expected == _mock_doEffect_called);
  }

  private int _mock_doEffect_expected;
  private int _mock_doEffect_called;
}
#+end_src

*** ~Effects~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/effect.zs

class tt_Effects : tt_Effect
{
  static tt_Effects of(Array<tt_Effect> effects)
  {
    let result = new("tt_Effects");
    result._effects.move(effects);
    return result;
  }

  override void doEffect()
  {
    foreach (effect : _effects)
      effect.doEffect();
  }

  private Array<tt_Effect> _effects;
}
#+end_src

*** ~Gunner~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/gunner.zs

// Implements tt_Effect by calling other tt_Effect if there is some tt_Origin.
class tt_Gunner : tt_Effect
{
  static tt_Gunner of(tt_OriginSource originSource, tt_Effect effect)
  {
    let result = new("tt_Gunner");
    result._originSource = originSource;
    result._effect       = effect;
    return result;
  }

  override void doEffect()
  {
    if (_originSource.getOrigin() != NULL) _effect.doEffect();
  }

  private tt_OriginSource _originSource;
  private tt_Effect       _effect;
}
#+end_src

**** Tests

#+begin_src c :noweb-ref test-body
{
  let tag = "tt_Gunner: null origin";
  let env = tt_GunnerTestEnvironment.of();

  env.originSource.expect_getOrigin(NULL);

  env.gunner.doEffect();

  assertSatisfaction(env.getSatisfaction(), tag);
}
{
  let tag = "tt_Gunner: valid origin";
  let env = tt_GunnerTestEnvironment.of();

  let origin = tt_Origin.of((0, 0, 0));

  env.originSource.expect_getOrigin(origin);
  env.effect.expect_doEffect();

  env.gunner.doEffect();

  assertSatisfaction(env.getSatisfaction(), tag);
}
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/environments.zs

class tt_GunnerTestEnvironment
{
  static tt_GunnerTestEnvironment of()
  {
    let result = new("tt_GunnerTestEnvironment");
    result.originSource = tt_OriginSourceMock.of();
    result.effect       = tt_EffectMock.of();
    result.gunner       = tt_Gunner.of(result.originSource, result.effect);
    return result;
  }

  tt_Satisfaction getSatisfaction() const
  {
    return originSource.getSatisfaction()
      .add(effect.getSatisfaction());
  }

  tt_OriginSourceMock originSource;
  tt_EffectMock       effect;
  tt_Gunner           gunner;
}
#+end_src

** ~AnswerResetter~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/answer_resetter.zs

class tt_AnswerResetter : tt_Effect
{
  static tt_AnswerResetter of(tt_AnswerStateSource answerStateSource,
                              tt_AnswerSource      answerSource)
  {
    let result = new("tt_AnswerResetter");

    result._answerStateSource = answerStateSource;
    result._answerSource      = answerSource;
    result._oldAnswerState    = tt_AnswerState.of(tt_AnswerState.Unknown);

    return result;
  }

  override void doEffect()
  {
    let newAnswerState = _answerStateSource.getAnswerState();
    if (!_oldAnswerState.isFinished() && newAnswerState.isFinished())
    {
      _answerStateSource.reset();
      _answerSource.reset();
    }

    _oldAnswerState = newAnswerState;
  }

  private tt_AnswerStateSource _answerStateSource;
  private tt_AnswerSource      _answerSource;

  private tt_AnswerState _oldAnswerState;
}
#+end_src

** ~MatchWatcher~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/match_watcher.zs

// Watches for answer state source and reports match or not match
// when the state changes from Preparing to Ready.
//
// Match is determined by tt_OriginSource result being not NULL.
class tt_MatchWatcher : tt_Effect
{
  static tt_MatchWatcher of(tt_AnswerStateSource answerStateSource,
                            tt_AnswerReporter    answerReporter,
                            tt_OriginSource      originSource)
  {
    let result = new("tt_MatchWatcher");

    result._answerStateSource = answerStateSource;
    result._answerReporter    = answerReporter;
    result._originSource      = originSource;
    result._oldAnswerState    = tt_AnswerState.of(tt_AnswerState.Unknown);

    return result;
  }

  override void doEffect()
  {
    let newAnswerState = _answerStateSource.getAnswerState();
    if (!_oldAnswerState.isReady() && newAnswerState.isReady())
    {
      let isMatched = (_originSource.getOrigin() != NULL);
      if (isMatched)
      {
        _answerReporter.reportMatch();
      }
      else
      {
        _answerReporter.reportNotMatch();
      }
    }

    _oldAnswerState = newAnswerState;
  }

  private tt_AnswerStateSource _answerStateSource;
  private tt_AnswerReporter    _answerReporter;
  private tt_OriginSource      _originSource;

  private tt_AnswerState _oldAnswerState;
}
#+end_src

** ~TargetOriginSender~

#+begin_src c :tangle build/Typist.pk3/zscript/effect/target_origin_sender.zs

class tt_TargetOriginSender : tt_Effect
{
  static tt_TargetOriginSender of(tt_OriginSource targetOriginSource)
  {
    let result = new("tt_TargetOriginSender");
    result._targetOriginSource = targetOriginSource;
    return result;
  }

  override void doEffect()
  {
    vector3 origin = _targetOriginSource.getOrigin().getVector();
    EventHandler.sendNetworkCommand("tt_target",
                                    NET_DOUBLE, origin.x,
                                    NET_DOUBLE, origin.y,
                                    NET_DOUBLE, origin.z);
  }

  private tt_OriginSource _targetOriginSource;
}
#+end_src

* Language

#+begin_src ini :tangle build/Typist.pk3/language.txt
[enu default]

// Menus ///////////////////////////////////////////////////////////////////////

TT_TITLE = "Typist.pk3 v0.7.4";

TT_UNLOCK = "Unlock Game Mode";
TT_COMBAT = "Force Combat Mode";
TT_SCORE  = "Open Score";

TT_TARGET_SCALE               = "Target text scale";

TT_QUESTION_SOURCE            = "Lesson";
TT_APPLY                      = "Apply";
TT_QUESTION_SOURCE_NOTE       = "Or existing targets will retain question from the previous Lesson.";

TT_CONTROLS_TITLE_OUT         = "Controls";
TT_CONTROLS_TITLE_IN          = "Typist.pk3 Controls";

TT_BUDDHA_ENABLED = "Player cannot die";
TT_BUDDHA_NOTE    = "Applies on new level start.";

TT_CONFIRMATION = "Answer confirmation";
TT_CONFIRMATION_MANUAL = "Enter/Space";
TT_CONFIRMATION_AUTO   = "As soon as it matches";

TT_LESSON_OPTIONS_TITLE_OUT = "Lesson Options";
TT_LESSON_OPTIONS_TITLE_IN  = "Typist.pk3 Lesson Options";

TT_LESSON_LETTERS = "Random Letters";
TT_LESSON_NUMBERS = "Random Numbers";
TT_LESSON_GZDOOM  = "GZDoom Dev";
TT_LESSON_CPP     = "C++";
TT_LESSON_MATH    = "Arithmetic";
TT_LESSON_1000    = "1000 Basic English Words";
TT_LESSON_1000_RU = "1000 Basic Russian Words";

TT_MIXED_LESSON            = "Mixed";
TT_MIXED_LESSON_TITLE      = "Mixed Lesson configuration";
TT_MIXED_LESSON_TITLE_FULL = "Typist.pk3 Mixed Lesson configuration";
TT_MIXED_LESSON_NOTE       = "Please enable at least one lesson.";

TT_CUSTOM_TEXT = "Custom Text";

TT_CUSTOM_LESSON_HELP_TEXT = "\cfHow to set up Custom Text lesson\c-\
\
1. Find any text or book in ASCII .txt file (UTF-8 may also work).\
2. Rename text file to `typist_custom_text.txt`.\
3. Load `typist_custom_text.txt` with GZDoom alongside Typist.pk3.\
4. Select Custom Text in Typist options menu.";

TT_NIX_LESSON = "*nix Command Line";

TT_LESSON_RANDOM              = "Random Characters";
TT_RANDOM_LESSON_TITLE        = "Random Characters Lesson Configuration";
TT_RANDOM_LESSON_LENGTH       = "Length";
TT_RANDOM_LESSON_UPPERCASE    = "A-Z";
TT_RANDOM_LESSON_LOWERCASE    = "a-z";
TT_RANDOM_LESSON_NUMBERS      = "0-9";
TT_RANDOM_LESSON_PUNCTUATION  = "Punctuation";
TT_RANDOM_LESSON_SYMBOLS      = "Other characters";
TT_RANDOM_LESSON_CUSTOM       = "Custom string";
TT_RANDOM_LESSON_CUSTOM_CHARS = "Custom string:";

// Sound menus /////////////////////////////////////////////////////////////////

TT_SOUND_OPTIONS_TITLE_OUT = "Sound Options";
TT_SOUND_OPTIONS_TITLE_IN  = "Typist.pk3 Sound Options";

TT_SOUND_THEME          = "Sound theme";
TT_SOUND_ENABLED        = "Sound effects";
TT_SOUND_TYPING_ENABLED = "Typing sound";

// Acknowledgments /////////////////////////////////////////////////////////////

TT_ACKNOWLEDGMENTS_TITLE = "Acknowledgments";
TT_ACKNOWLEDGMENTS_TITLE_FULL = "Typist.pk3 Acknowledgments";
TT_ACKNOWLEDGMENTS_TEXT = "\cfCredits\c-\n\n- libeye (Level and screen projections): KeksDose\n- Clematis: ZippeyKeys12 (Zain Aamer)\n- miniwad.wad: fraggle\n- 1000 basic English words: Wikipedia\n- Frequency dictionary of the modern Russian language: Wikipedia\n- Sound design: Captain J\n\n\cfThanks\c-\n\n- LGR for Sega's Typing of the Dead: A Zombie-Slaying Education video\n- Marrub for ZScript documentation\n- Accensus for inviting me into Discord server and for bug reports\n- kadu522 for support\n- dard22 for bug reports\n- Jarewill for bug reports\n\n(see details in the Readme.md file inside the pk3)\n";
#+end_src

* Options Menu

** Options

TODO: rewrite with PlainTranslator.

#+begin_src c :tangle build/Typist.pk3/menudef.txt

AddOptionMenu OptionsMenu
{
  tt_AnimatedSubmenu "$TT_TITLE", tt_Options
}

OptionMenu tt_Options
{
  Title      "$TT_TITLE"

  Submenu    "$TT_CONTROLS_TITLE_OUT"         , tt_Controls

  StaticText ""
  Submenu    "General Options"                , tt_GeneralOptions
  Submenu    "$TT_LESSON_OPTIONS_TITLE_OUT"   , tt_LessonOptions
  Submenu    "$TT_SOUND_OPTIONS_TITLE_OUT"    , tt_SoundOptions

  StaticText ""
  Submenu    "$TT_ACKNOWLEDGMENTS_TITLE"      , tt_Acknowledgments
}

OptionMenu tt_GeneralOptions
{
  Title      "Typist.pk3 General Options"

  StaticText ""
  Option     "$TT_CONFIRMATION", tt_confirm_type, tt_ConfirmationTypes

  StaticText ""
  Slider     "$TT_TARGET_SCALE", tt_view_scale, 1, 4, 1, 0

  StaticText ""
  StaticText "Reduce distractions"

  StaticText ""
  Option     "$TT_BUDDHA_ENABLED", tt_buddha_enabled, OnOff
  StaticText "$TT_BUDDHA_NOTE"

  StaticText ""
  Option     "Infinite ammo",      sv_infiniteammo, OnOff

  StaticText ""
  Option     "HUD",          screenblocks, tt_HudValues
  Option     "Show score",   tt_lp_show, OnOff
  Slider     "Pain flash",   blood_fade_scalar,  0, 1.0, 0.1
  Slider     "Pickup flash", pickup_fade_scalar, 0, 1.0, 0.1
}

OptionValue tt_HudValues
{
  10, "Standard"
  11, "Alternative"
  12, "No HUD"
}

OptionMenu tt_LessonOptions
{
  Title      "$TT_LESSON_OPTIONS_TITLE_IN"

  Option     "$TT_QUESTION_SOURCE", tt_question_source, tt_LessonValues

  StaticText ""
  Submenu    "$TT_MIXED_LESSON_TITLE", tt_MixedLesson
  Submenu    "$TT_RANDOM_LESSON_TITLE", tt_RandomLesson

  StaticText ""
  Command    "$TT_APPLY", tt_reset_targets
  StaticText "$TT_QUESTION_SOURCE_NOTE"

  StaticText ""
  StaticText "$TT_CUSTOM_LESSON_HELP_TEXT"
}

OptionMenu tt_Controls
{
  Title      "$TT_CONTROLS_TITLE_IN"

  Control    "$TT_UNLOCK", tt_unlock_mode
  Control    "$TT_COMBAT", tt_force_combat

  StaticText ""
  TextField  "Pass Through command", tt_command_pass_through
  StaticText "Allows a single action key to be pressed without exiting Combat mode."

  StaticText ""
  Control    "$TT_SCORE", zc_top
}

OptionMenu tt_SoundOptions
{
  Title  "$TT_SOUND_OPTIONS_TITLE_IN"

  Option "$TT_SOUND_ENABLED"        , tt_sound_enabled        , OnOff
  Option "$TT_SOUND_TYPING_ENABLED" , tt_sound_typing_enabled , OnOff
  Option "$TT_SOUND_THEME"          , tt_sound_theme          , tt_SoundThemes
}

OptionMenu tt_Acknowledgments
{
  Title "$TT_ACKNOWLEDGMENTS_TITLE_FULL"

  StaticText "$TT_ACKNOWLEDGMENTS_TEXT"
}

OptionMenu tt_MixedLesson
{
  Title "$TT_MIXED_LESSON_TITLE_FULL"

  // TODO: add this doc.
  // See docs/adding-new-lesson.md.
  Option "$TT_LESSON_RANDOM"  , tt_is_lesson_enabled_0 , OnOff
  Option "$TT_LESSON_GZDOOM"  , tt_is_lesson_enabled_1 , OnOff
  Option "$TT_LESSON_CPP"     , tt_is_lesson_enabled_2 , OnOff
  Option "$TT_LESSON_MATH"    , tt_is_lesson_enabled_3 , OnOff
  Option "$TT_LESSON_1000"    , tt_is_lesson_enabled_4 , OnOff
  Option "$TT_LESSON_1000_RU" , tt_is_lesson_enabled_5 , OnOff
  Option "$TT_CUSTOM_TEXT"    , tt_is_lesson_enabled_6 , OnOff
  Option "$TT_NIX_LESSON"     , tt_is_lesson_enabled_7 , OnOff

  StaticText ""
  StaticText "$TT_MIXED_LESSON_NOTE"

  StaticText ""
  Command    "$TT_APPLY", tt_reset_targets
  StaticText "$TT_QUESTION_SOURCE_NOTE"
}

OptionMenu tt_RandomLesson
{
  Title  "$TT_RANDOM_LESSON_TITLE_FULL"

  Slider "$TT_RANDOM_LESSON_LENGTH", tt_rc_length, 1, 10, 1, 0

  StaticText ""
  Option "$TT_RANDOM_LESSON_UPPERCASE"   , tt_rc_uppercase_letters_enabled , OnOff
  Option "$TT_RANDOM_LESSON_LOWERCASE"   , tt_rc_lowercase_letters_enabled , OnOff
  Option "$TT_RANDOM_LESSON_NUMBERS"     , tt_rc_numbers_enabled           , OnOff
  Option "$TT_RANDOM_LESSON_PUNCTUATION" , tt_rc_punctuation_enabled       , OnOff
  Option "$TT_RANDOM_LESSON_SYMBOLS"     , tt_rc_symbols_enabled           , OnOff

  StaticText ""
  Option     "$TT_RANDOM_LESSON_CUSTOM"       , tt_rc_custom_enabled , OnOff
  TextField  "$TT_RANDOM_LESSON_CUSTOM_CHARS" , tt_rc_custom
}
#+end_src

#+begin_src c :tangle build/Typist.pk3/menudef.txt

// See docs/adding-new-lesson.md.
OptionValue tt_LessonValues
{
  0 , "$TT_LESSON_RANDOM"
  1 , "$TT_LESSON_GZDOOM"
  2 , "$TT_LESSON_CPP"
  3 , "$TT_LESSON_MATH"
  4 , "$TT_LESSON_1000"
  5 , "$TT_LESSON_1000_RU"
  6 , "$TT_MIXED_LESSON"
  7 , "$TT_CUSTOM_TEXT"
  8 , "$TT_NIX_LESSON"
}

OptionValue tt_ConfirmationTypes
{
  0, "$TT_CONFIRMATION_MANUAL"
  1, "$TT_CONFIRMATION_AUTO"
}

OptionValue tt_SoundThemes
{
  1, "Default"
  2, "SNES"
  4, "Dakka"
  5, "Grocery Store"
}

// Score Menu
OptionMenu tt_lp_TopMenu
{
  class tt_lp_Top
  Title "Top Points"
}
#+end_src

** Keys

#+begin_src c :tangle build/Typist.pk3/keyconf.txt

Alias tt_unlock_mode   "event tt_unlock_mode"
Alias tt_force_combat  "event tt_force_combat"
Alias tt_reset_targets "event tt_reset_targets"

Alias zc_top "openMenu tt_lp_TopMenu"

AddKeySection "$TT_TITLE" tt_keys
AddMenuKey "$TT_UNLOCK" tt_unlock_mode
AddMenuKey "$TT_COMBAT" tt_force_combat
AddMenuKey "$TT_SCORE"  zc_top
#+end_src

** ~AnimatedSubmenu~

#+begin_src c :tangle build/Typist.pk3/zscript/menu/option_menu_item_animated_submenu.zs

class OptionMenuItemtt_AnimatedSubmenu : OptionMenuItemSubmenu
{
  // Signature mirrors OptionMenuItemSubmenu.Init().
  OptionMenuItemtt_AnimatedSubmenu Init( string label
                                       , Name   command
                                       , int    param    = 0
                                       , bool   centered = false
                                       )
  {
    Super.Init(label, command, param, centered);

    _originalLabel  = stringTable.Localize(label);
    _originalLength = _originalLabel.CodePointCount();
    _period         = DELAY_TICS + _originalLength * CHARACTER_TIMEOUT_TICS;

    return self;
  }

  override int Draw(OptionMenuDescriptor desc, int y, int indent, bool selected)
  {
    int highlightedLetterIndex = _state / CHARACTER_TIMEOUT_TICS;

    if (highlightedLetterIndex < _originalLength)
    {
      int letterCode;
      int charPos = 0;
      for (int i = 0; i < highlightedLetterIndex; ++i)
      {
        [letterCode, charPos] = _originalLabel.GetNextCodePoint(charPos);
      }

      string left           = _originalLabel.Left(charPos);
      [letterCode, charPos] = _originalLabel.GetNextCodePoint(charPos);
      string right          = _originalLabel.Mid(charPos, _originalLabel.Length() - charPos);

      mLabel = string.format("%s\cd%c\c-%s", left, letterCode, right);
    }
    else
    {
      mLabel = _originalLabel;
    }

    ++_state;
    if (_state >= _period)
    {
      _state = 0;
    }

    return Super.Draw(desc, y, indent, selected);
  }

  const DELAY_TICS = 5 * TICRATE;
  const CHARACTER_TIMEOUT_TICS = 3;

  private int    _state;
  private int    _period;
  private string _originalLabel;
  private int    _originalLength;
}
#+end_src

* Sndinfo

#+begin_src c :tangle build/Typist.pk3/sndinf.txt

// Global Typist sound settings ////////////////////////////////////////////////

// Do not randomize pitch shift value.
$pitchshiftrange 0

// 1. Default sound theme //////////////////////////////////////////////////////

tt/combat1    "sounds/Default/danger1.ogg"
tt/explore1   "sounds/Default/safe1.ogg"
tt/click1-1   "sounds/Default/typea1.ogg"
tt/click1-2   "sounds/Default/typea2.ogg"
tt/click1-3   "sounds/Default/typea3.ogg"
tt/click1-4   "sounds/Default/typea4.ogg"
tt/click1-5   "sounds/Default/typea5.ogg"
tt/match1     "sounds/Default/success1.ogg"
tt/not-match1 "sounds/Default/fail1.ogg"

$random tt/click1 { tt/click1-1 tt/click1-2 tt/click1-3 tt/click1-4 tt/click1-5 }

$volume tt/combat1  0.4
$volume tt/explore1 0.6
$volume tt/match1   0.4

// 2. SNES sound theme /////////////////////////////////////////////////////////

tt/combat2    "sounds/SNES/danger2.ogg"
tt/explore2   "sounds/SNES/safe2.ogg"
tt/click2-1   "sounds/SNES/typeb1.ogg"
tt/click2-2   "sounds/SNES/typeb2.ogg"
tt/click2-3   "sounds/SNES/typeb3.ogg"
tt/click2-4   "sounds/SNES/typeb4.ogg"
tt/click2-5   "sounds/SNES/typeb5.ogg"
tt/match2     "sounds/SNES/success2.ogg"
tt/not-match2 "sounds/SNES/sneserrors.ogg"

$random tt/click2 { tt/click2-1 tt/click2-2 tt/click2-3 tt/click2-4 tt/click2-5 }

// 4. Dakka sound theme ////////////////////////////////////////////////////////

tt/combat4    "sounds/Dakka/danger4.ogg"
tt/explore4   "sounds/Dakka/safe4.ogg"
tt/click4-1   "sounds/Dakka/typed1.ogg"
tt/click4-2   "sounds/Dakka/typed2.ogg"
tt/click4-3   "sounds/Dakka/typed3.ogg"
tt/click4-4   "sounds/Dakka/typed4.ogg"
tt/click4-5   "sounds/Dakka/typed5.ogg"
tt/match4     "sounds/Dakka/success4.ogg"
tt/not-match4 "sounds/Dakka/fail4.ogg"

$random tt/click4 { tt/click4-1 tt/click4-2 tt/click4-3 tt/click4-4 tt/click4-5 }

// 5. GroceryStore sound theme /////////////////////////////////////////////////

tt/combat5    "sounds/GroceryStore/danger5.ogg"
tt/explore5   "sounds/GroceryStore/safe5.ogg"
tt/click5-1   "sounds/GroceryStore/typee1.ogg"
tt/click5-2   "sounds/GroceryStore/typee2.ogg"
tt/click5-3   "sounds/GroceryStore/typee3.ogg"
tt/click5-4   "sounds/GroceryStore/typee4.ogg"
tt/click5-5   "sounds/GroceryStore/typee5.ogg"
tt/match5     "sounds/GroceryStore/success5.ogg"
tt/not-match5 "sounds/GroceryStore/fail5.ogg"

$random tt/click5 { tt/click5-1 tt/click5-2 tt/click5-3 tt/click5-4 tt/click5-5 }

$volume tt/click5 0.2
#+end_src

* Mod setup

#+begin_src c :tangle build/Typist.pk3/zscript.zs

version 4.14.2

<<tools/scripts.org:include("Typist.pk3.org", "build/Typist.pk3/\\(zscript/.*zs\\)")>>

#include "zscript/tt_le_libeye.zs"
#include "zscript/tt_lp_LazyPoints.zs"
#include "zscript/tt_su_StringUtils.zs"
#+end_src

#+begin_src text :tangle build/tmp.txt :exports none
<<tools/scripts.org:copy-media("Typist.pk3")>>
#+end_src

#+begin_src c :tangle build/Typist.pk3/mapinfo.txt

GameInfo
{
  EventHandlers =
    "tt_lp_Dispatcher",
    "tt_lp_StaticView",
    "tt_EventHandler"
}
#+end_src

#+begin_src c :tangle build/Typist.pk3/cvarinfo.txt

// Variables for score /////////////////////////////////////////////////////////

nosave string tt_lp_score = "";
user   bool   tt_lp_show  = true;
#+end_src

* Tests

#+begin_src c :tangle build/Typist.pk3Test/zscript.zs

version 4.14.2

<<tools/scripts.org:include("Typist.pk3.org", "build/Typist.pk3Test/\\(zscript/.*zs\\)")>>
#+end_src

#+begin_src c :tangle build/Typist.pk3Test/zscript/test.zs

class tt_Test : Clematis
{
  override void testSuites()
  {
    Describe("Typist tests");
    addTests();
    EndDescribe();
  }

  play void addTests() const
  {
    <<test-body>>
  }

  // Note: don't forget to call cleanUpSpawned at the end of the test case!
  protected play Actor spawn(class<Actor> type, vector3 pos) const
  {
    let result = Actor.spawn(type, pos);
    _spawned.push(result);
    return result;
  }

  // Note: don't forget to call cleanUpSpawned at the end of the test case!
  protected play Actor spawnDead(class<Actor> type, vector3 pos) const
  {
    let result = Actor.spawn(type, pos);
    result.a_Die();
    _spawned.push(result);
    return result;
  }

  protected play void cleanUpSpawned() const
  {
    foreach (anActor : _spawned)
      anActor.destroy();

    _spawned.clear();
  }

  protected void assertSatisfaction(tt_Satisfaction satisfaction, string tag)
  {
    foreach (mock, isSatisfied : satisfaction.values)
      it(tag .. ": " .. mock, Assert(isSatisfied));
  }

  Array<Actor> _spawned;
}

class tt_Satisfaction
{
  static tt_Satisfaction of()
  {
    return new("tt_Satisfaction");
  }

  tt_Satisfaction add(tt_Satisfaction other)
  {
    foreach (tag, value : other.values)
      values.insert(tag, value);
    return self;
  }

  tt_Satisfaction push(string tag, bool value)
  {
    values.insert(tag, value);
    return self;
  }

  Map<string, bool> values;
}
#+end_src

* Run :noexport:

Note: ~sv_fastweapons~ is for ~tt_Firer~ test.

#+begin_src text :tangle build/Typist.pk3Test/commands.txt
wait 2; map map01; sv_fastweapons 2; wait 2; netevent test:tt_Test; wait 2; quit
#+end_src

#+begin_src elisp
(compile "scons -Q Typist.pk3Test")
#+end_src
