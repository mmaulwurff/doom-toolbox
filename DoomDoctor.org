# SPDX-FileCopyrightText: © 2021 Alexander Kromm <mmaulwurff@gmail.com>
# SPDX-License-Identifier: CC0-1.0
:properties:
:header-args: :comments no :mkdirp yes :noweb yes :results none
:end:
#+title: Doom Doctor

* Q: Wait! Where are the project files?
A: This is Emacs Org mode literate project file. Use Emacs to extract the individual
files. You don't have to open the Emacs window. The command to extract the files is:

emacs this_file.org --quick --batch --funcall=org-babel-tangle

* Doom Doctor
Doom Doctor is a utility mod for ZScript'ed game engines.

* Features
- VM abort reports (controlled by dd_vm_abort_report_enabled cvar):
  - basic game information: map name, total time, multiplayer status, player
    class, skill;
  - game configuration: compat flags, dm flags, autoaim;
  - event handler list;
  - system time;
  - a request for the user to report the bug.

If there are several VM abort handlers loaded, only the first one will print
stuff. For this to work, all handlers must have "VmAbortHandler" somewhere in
their class name.

Also there is ~dd_report~ console command for gathering a report by manual request.

* Acknowledgments
- Thanks to KeksDose for the concept of VM abort handler.
- Thanks to Colerx for bug reports.
- Thanks to Accensus for feature suggestions.

* Launch :noexport:
src_elisp{(load-file "build/TestRunner/dt-scripts.el")}
src_elisp{(run-tests "")}
# src_elisp{(run-tests "wait 1; quit")}
# src_elisp{(run-tests "wait 1; save-load")}

* Licenses :noexport:
#+name: CC
#+begin_src :exports none
SPDX-FileTextCopyright: © 2021 Alexander Kromm <mmaulwurff@gmail.com>
SPDX-License-Identifier: CC0-1.0
#+end_src

#+name: GPL
#+begin_src :exports none
SPDX-FileTextCopyright: © 2021 Alexander Kromm <mmaulwurff@gmail.com>
SPDX-License-Identifier: GPL-3.0-only
#+end_src

* Console alias configuration
#+begin_src txt :tangle build/DoomDoctor/keyconf.txt
// <<CC>>

alias dd_report "event dd_report"
#+end_src

* Event handler declaration
#+begin_src txt :tangle build/DoomDoctor/mapinfo.txt
// <<CC>>

gameinfo { AddEventHandlers = "dd_VmAbortHandler" }
#+end_src

* Console variables
#+begin_src txt :tangle build/DoomDoctor/cvarinfo.txt
// <<CC>>

user bool dd_vm_abort_report_enabled = true;
#+end_src

* Tests preamble
#+begin_src txt :tangle build/DoomDoctorTest/mapinfo.txt
// <<CC>>

gameinfo { AddEventHandlers = "dd_TestEventHandler" }
#+end_src

# SPDX-SnippetBegin
# SPDX-License-Identifier: GPL-3.0-only
# SPDX-SnippetCopyrightText: © 2021 Alexander Kromm <mmaulwurff@gmail.com>
#+begin_src c :tangle build/DoomDoctorTest/zscript.txt
// <<GPL>>

version 4.12.2

class dd_TestEventHandler : StaticEventHandler
{
  override void onEngineInitialize() { Clematis.Create("dd_Test"); }
}

class dd_Test : Clematis
{
  override void TestSuites()
  {
#+end_src
# SPDX-SnippetEnd

* Source code
# SPDX-SnippetBegin
# SPDX-License-Identifier: GPL-3.0-only
# SPDX-SnippetCopyrightText: © 2021 Alexander Kromm <mmaulwurff@gmail.com>
#+begin_src c :tangle build/DoomDoctor/zscript.txt
// <<GPL>>

version 4.12.2

class dd_VmAbortHandler : EventHandler
{

  override void playerSpawned(PlayerEvent event)
  {
    mReport = new("dd_Report");
    if (event.playerNumber == consolePlayer) mReport.writePlayerInfo();
  }

  override void uiTick()
  {
    bool isOnceASecond = level.totalTime % TICRATE == 0;
    if (isOnceASecond) mReport.writeSystemTime();
  }

  override void onDestroy()
  {
    if (gameState != GS_FullConsole
        || !amIFirst()
        || !Cvar.getCvar("dd_vm_abort_report_enabled", players[consolePlayer]).getBool())
      {
        return;
      }

    mReport.printReport();
    printAttention();
  }

  override void consoleProcess(ConsoleEvent event)
  {
    if (amIFirst() && event.name == "dd_report")
      {
        mReport.printReport();
        printAttention();
      }
  }

  private clearscope bool amIFirst()
  {
    foreach (aClass : AllClasses)
      {
        string className = aClass.getClassName();
        bool isVmAbortHandler = (className.indexOf("VmAbortHandler") != -1);

        if (!isVmAbortHandler) continue;

        return className == getClassName();
      }
    return false;
  }

  clearscope void printAttention()
  {
    string userName = players[consolePlayer].getUserName();
    string message1 = string.format( "  # %s\cg, please report this VM abort to mod author."
                                     , userName
                                     );
    string message2 = "  # Attach screenshot to the report.";
    string message3 = "  # Type \"screenshot\" below to take a screenshot.";

    Array<string> tokens;
    userName.split(tokens, "\c");
    int colorCharsCount = (tokens.size() - 1) * 3;
    int length = max(max(message1.length() - colorCharsCount, message2.length()), message3.length());

    message1 = fillBox(message1, length);
    message2 = fillBox(message2, length);
    message3 = fillBox(message3, length);

    string hashes;
    for (int i = 0; i < length; ++i)
      {
        hashes = hashes .. "#";
      }
    Console.printf("\n\cg  %s\n%s\n%s\n%s\n  %s\n", hashes, message1, message2, message3, hashes);
  }

  private static clearscope string fillBox(string result, int length)
  {
    for (int i = result.length(); i < length; ++i) result.appendFormat(" ");
    result.appendFormat(" #");
    return result;
  }

  private dd_Report mReport;
}

class dd_Report
{

  clearscope void writePlayerInfo()
  {
    mPlayerClassName = players[consolePlayer].mo.getClassName();
    mSkillName       = g_SkillName();
  }

  ui void writeSystemTime()
  {
    mSystemTime = SystemTime.now();
  }

  clearscope void printReport()
  {
    printVersion();
    Console.Printf("%s", getGameInfo());
    printConfiguration();
    printEventHandlers();
    printRealTime();
  }

  private static clearscope string getCvarIntValueAsString(string cvarName)
  {
    let aCvar = Cvar.getCvar(cvarName, players[consolePlayer]);
    return aCvar ? string.format("%s: %d", cvarName, aCvar.getInt()) : "";
  }

  private static clearscope string getCvarFloatValueAsString(string cvarName)
  {
    let aCvar = Cvar.getCvar(cvarName, players[consolePlayer]);
    return aCvar ? string.format("%s: %f", cvarName, aCvar.getFloat()) : "";
  }

  private static clearscope void printConfiguration()
  {
    Array<string> configuration =
      {
        getCvarIntValueAsString("compatflags"),
        getCvarIntValueAsString("compatflags2"),
        getCvarIntValueAsString("dmflags"),
        getCvarIntValueAsString("dmflags2"),
        getCvarFloatValueAsString("autoaim")
      };

    Console.printf("%s", dd_su.join(configuration, ", "));
  }

  private static clearscope void printVersion()
  {
    Console.printf("Doom Doctor");
  }

  private clearscope string getGameInfo()
  {
    return string.format(
                         "Game: level: %s, time: %d, multiplayer: %d, player class: %s, skill: %s.",
                         level.mapName, level.totalTime, multiplayer, mPlayerClassName, mSkillName);
  }

  private static clearscope void printEventHandlers()
  {
    Array<string> eventHandlers;

    foreach (aClass : AllClasses)
      {
        if (!(aClass is "StaticEventHandler")) continue;
        if (aClass == "StaticEventHandler" || aClass == "EventHandler") continue;

        eventHandlers.push(aClass.getClassName());
      }

    Console.printf("Event handlers: %s", dd_su.join(eventHandlers, ", "));
  }

  private clearscope void printRealTime()
  {
    Console.printf("System time: %s", SystemTime.format("%F %T %Z", mSystemTime));
  }

  private string mPlayerClassName;
  private string mSkillName;
  private int mSystemTime;
}

<<modules()>>
#+end_src
# SPDX-SnippetEnd

* Modules
#+name: modules
#+begin_src emacs-lisp
(load-file "build/TestRunner/dt-scripts.el")

(tangle-module "dd_" "StringUtils")
#+end_src

* Tests end
#+begin_src c :tangle build/DoomDoctorTest/zscript.txt
}}
#+end_src

* TODO
- test manually for regressions
- fix colored user names
- update logo
- update licenses
- incorporate Mod Compatibility Checklist
