# SPDX-FileCopyrightText: © 2024 Alexander Kromm <mmaulwurff@gmail.com>
# SPDX-License-Identifier: CC0-1.0

#+title: Where Are The Project Files?

Doom Toolbox projects are written as Emacs Org-mode literate project files. Use Emacs to extract the individual files. You don't have to open the Emacs window. Use the following command line command to extract source code from a file named File.org:

emacs File.org --quick --batch --eval "(progn (require 'ob-tangle) (setq org-confirm-babel-evaluate nil) (org-babel-tangle))"

or run this Python script which launches Emacs: ~tools/tangle.py File.org~

⚠ !WARNING! Org files may contain code, and extracting the source files from it may execute it. Don't extract files from Org files from the sources you don't trust.

The breakdown of the script above:
- launch Emacs with the File.org file:
  - ~--quick~ - don't load the Emacs settings and don't show the splash screen,
  - ~--batch~ - launch Emacs without interface, so it processes the command and exits,
  - ~--eval~ - run the following Elisp commands:
    - ~progn~ - run the following command sequence;
    - ~require 'ob-tangle~ - load the Emacs module for extracting source code from .org files;
    - ~setq org-confirm-babel-evaluate nil~ - allow running code from .org file, which is used for macros and text generation. Running code from .org file is disabled by default;
    - ~org-babel-tangle~ - extract source code from .org file to separate files.

* Pros

** Logical code structure

You can put related program components together, even if they are in different languages or file formats. Like this: conventional code structure:
- application/file1: feature1 documentation, feature2 documentation;
- application/file2: feature1 source code, feature2 source code;
- tests/file3: feature1 tests, feature2 tests.

Logical code structure:
- file1:
  - section1: feature1 documentation, feature1 source code, feature1 tests,
  - section2: feature2 documentation, feature2 source code, feature2 tests.

** Macros

Your project's main programming language can be extended with a scripting language like Python or Emacs Lisp, which can be used to generate code. Great for boilerplate code.

Features of macros in Emacs Lisp inside an .org file that I haven't found in other literal project systems:
- access to tangled file whole text (for whole project analysis),
- shared environment across macro invocations (for counters).

** Links

To file sections, to other files, URLs.

** HTML documentation

Export to HTML produces a very nicely formatted document. Also, GitHub shows .org files as a formatted HTML page, though macros and ~:noexport:~ sections are not supported.

* Cons

** Limited text editor choice

There is some support for Org-mode for editors other than Emacs, but I believe code execution, especially Emacs Lisp, is out of the question for them.

** Limited project size

Emacs may become less responsive with big and complex Org-mode files. Projects with big feature scope will be difficult to understand as one file. But, maybe it's a good thing, and helps prevent feature creep?

** Extra syntax

Markers for code blocks: ~#+begin_src~, ~#+end_src~, etc litter the file. Besides your project's main programming language syntax and formatting, you now also have to spend time formatting Org.

** Compilation error reporting

The compiler reports errors and warnings with line numbers of the source files that are extracted from the Org files, not line numbers in the Org file.

** Licensing mess

If you want to license your project properly and apply different licenses to project source files and documentation, it's a hassle to do that.
